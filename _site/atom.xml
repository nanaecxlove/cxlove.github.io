<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title></title>
 <link href="/atom.xml" rel="self"/>
 <link href=""/>
 <updated>2014-05-20T15:19:19+08:00</updated>
 <id></id>
 <author>
   <name></name>
   <email></email>
 </author>

 
 <entry>
   <title>My First Blog</title>
   <link href="/informal%20essay/2014/05/19/HelloWorld.html"/>
   <updated>2014-05-19T00:00:00+08:00</updated>
   <id>/informal%20essay/2014/05/19/HelloWorld</id>
   <content type="html">
&lt;h1 id=&quot;hello-world&quot;&gt;Hello World&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;#includ &amp;lt;iostream&amp;gt;
using namespace std;
int main () {
	cout &amp;lt;&amp;lt; &quot;Hello World&quot; &amp;lt;&amp;lt; endl;
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;

</content>
 </entry>
 
 <entry>
   <title>MOLO前端规范</title>
   <link href="/f2e/2012/11/07/molo-f2e-standard.html"/>
   <updated>2012-11-07T00:00:00+08:00</updated>
   <id>/f2e/2012/11/07/molo-f2e-standard</id>
   <content type="html">
&lt;h3 id=&quot;molo&quot;&gt;molo前端规范&lt;/h3&gt;

&lt;h4 id=&quot;section&quot;&gt;一、命名规范：&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;公共组件因高度重用，命名从简，不要加前缀&lt;/li&gt;
  &lt;li&gt;各页面class和id采用驼峰命名法，有JS关联的dom对象采用“J_SubjectPagin”此格式书写，防止页面改版等更新需求时误删js钩子。&lt;/li&gt;
  &lt;li&gt;频道下的页面命名清晰，不怕命名长，怕命名冲突。命名长，css选择时可尽量不使用子选择符，确保css优先级权重足够低。方便扩展时覆盖操作。&lt;/li&gt;
  &lt;li&gt;命名有意义，尽量采用英文。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-1&quot;&gt;二、注释规范&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;公共组件需要在文件头部加上注释说明：&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  /**
  * usage：
  * author：
  * email：
  * date：	
  **/
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;大模块注释，用==分隔开：&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  //===================
  //代码用途
  //===================
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;小功能注释，单独占一行，不要在代码后的同一行内加注释：&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  //代码用途
  var name = &quot;abc&quot;;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-2&quot;&gt;公共组件开发规范&lt;/h4&gt;

&lt;h4 id=&quot;html&quot;&gt;HTML规范&lt;/h4&gt;

&lt;h4 id=&quot;css&quot;&gt;CSS规范&lt;/h4&gt;

&lt;h4 id=&quot;js&quot;&gt;JS规范&lt;/h4&gt;

</content>
 </entry>
 
 <entry>
   <title>FreeMarker学习笔记</title>
   <link href="/freemarker/2012/11/02/freemarker.html"/>
   <updated>2012-11-02T00:00:00+08:00</updated>
   <id>/freemarker/2012/11/02/freemarker</id>
   <content type="html">
&lt;h3 id=&quot;freemarkerrequestsession&quot;&gt;1.freemarker中Request,Session的用法：&lt;/h3&gt;
&lt;p&gt;java块:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;request.getSession().setAttribute(&quot;qq&quot;,&quot;http://www.qq.com&quot;);  
request.setAttribute(&quot;qq&quot;, &quot;http://www.qq.com&quot;);  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;freemarker代码：  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;#if Session [&quot;qq&quot;]?exists&amp;gt;//Request的用法同session  
&amp;lt;#if Session [&quot;qq&quot;]==&quot;http://www.qq.com&quot;&amp;gt;  
&amp;lt;#else&amp;gt;  
&amp;lt;/#if&amp;gt;  
&amp;lt;#else&amp;gt;  
&amp;lt;/#if&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而通常情况下，Request和Session均可省去不写：  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;#if qq?exists&amp;gt;//Request的用法同session  
	&amp;lt;#if qq==&quot;http://www.qq.com&quot;&amp;gt;  
	&amp;lt;#else&amp;gt;  
	&amp;lt;/#if&amp;gt;  
&amp;lt;#else&amp;gt;  
&amp;lt;/#if&amp;gt;   但是如果他们都设有相同的key值，那么在页面中显示的话，就就应该把他们加上去。  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;freemarker&quot;&gt;2.freemarker获取字数&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;#assign content=root.keyWord&amp;gt;
${content?subString(0,100)}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;${root.keyWord[0..100]} 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section&quot;&gt;3.判断集合：&lt;/h3&gt;
&lt;p&gt;集合的集合： &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;#if voteWraperObj.itemList?size gt 0&amp;gt;  
	&amp;lt;#list voteWraperObj.itemList as voteList&amp;gt;  
	&amp;lt;/#list&amp;gt;              
&amp;lt;/#if&amp;gt;   对象的集合：  

&amp;lt;#if softDetail?size gt 0&amp;gt;  
	&amp;lt;#list softDetail as softlist&amp;gt;  
	&amp;lt;/#list&amp;gt;  
&amp;lt;/#if&amp;gt;   关于Session中存放的对象的属性的读取：  

&amp;lt;#if Session [&quot;userweb&quot;].member?exists&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;判断数组是否存在
&amp;lt;#if list??&amp;gt;&lt;/p&gt;

&lt;h3 id=&quot;switchcase&quot;&gt;4.switch/case的用法：&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;#switch type&amp;gt;  
	&amp;lt;#case &quot;down&quot;&amp;gt;  
		&amp;lt;#include &quot;softdown.ftl&quot;&amp;gt;  
		&amp;lt;#break&amp;gt;  
	&amp;lt;#case &quot;photo&quot;&amp;gt;  
		&amp;lt;#if para==&quot;photoSquare&quot;&amp;gt;  
			&amp;lt;#include &quot;photo.ftl&quot;&amp;gt;  
		&amp;lt;#elseif para==&quot;photoWidth&quot;&amp;gt;  
			&amp;lt;#include &quot;photo.ftl&quot;&amp;gt;  
		&amp;lt;#else&amp;gt;  
		&amp;lt;/#if&amp;gt;  
	&amp;lt;#break&amp;gt;  
&amp;lt;/#switch&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-1&quot;&gt;5.时间类型在页面是如何才能正常显示的：&lt;/h3&gt;
&lt;p&gt;如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;${newslist.pubTime?string(&#39;yyyy-MM-dd&#39;)}  
${newslist.pubTime?string(&quot;yyyy-MM-dd HH:mm:ss&quot;)}   
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-2&quot;&gt;6.判断存在与否，以及是否有效：&lt;/h3&gt;
&lt;p&gt;如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;#if goodslist.f_goods_url?exists&amp;amp;&amp;amp;goodslist.f_goods_url?length gt 0&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;default&quot;&gt;7.”default”是如何使用的：&lt;/h3&gt;
&lt;p&gt;如： &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;${qq?default(&quot;http://www.qq.com&quot;)}  
//即如果属性qq不存在，那么就是要default中的值替代。  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;assign&quot;&gt;8.&lt;code&gt;&amp;lt;#assign&amp;gt;&lt;/code&gt;的用法：&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;#assign count=0&amp;gt;  
&amp;lt;#assign str=&quot;12345&quot;&amp;gt;  
&amp;lt;#list 0..9 as i&amp;gt;  
	&amp;lt;#assign count=count+1&amp;gt;   
	&amp;lt;#if i gt str?length&amp;gt;  
		${count}  
	&amp;lt;/#if&amp;gt;  
&amp;lt;/#list&amp;gt;   输出为：7 8 9 10  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;freemarker-1&quot;&gt;9.freemarker中如何截取字符串&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;exp?substring(from, toExclusive)&lt;/code&gt; 
&lt;code&gt;exp?substring(from)&lt;/code&gt; 
实例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;${&#39;abc&#39;?substring(0)}//abc
${&#39;abc&#39;?substring(0, 3)} //abc
${&#39;abc&#39;?substring(2, 3)} //c
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;freemarker-2&quot;&gt;10.freemarker页面中如果包含&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;#assign html=JspTaglibs[&quot;/WEB-INF/struts-html.tld&quot;]&amp;gt;  
&amp;lt;@html.base/&amp;gt;   那么它所指向的路径都是相对路径(相对于当前文件)。  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;freemarkerhtml&quot;&gt;11.如何让freemarker模板当html来使用呢：（完整的页面如下）&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;html&amp;gt;  
&amp;lt;head&amp;gt;  
    &amp;lt;#assign html=JspTaglibs[&quot;/WEB-INF/struts-html.tld&quot;]&amp;gt;  
    &amp;lt;#assign bean=JspTaglibs[&quot;/WEB-INF/struts-bean.tld&quot;]&amp;gt;  
    &amp;lt;#assign logic=JspTaglibs[&quot;/WEB-INF/struts-logic.tld&quot;]&amp;gt;  
    &amp;lt;@html.base/&amp;gt;  
    &amp;lt;link href=&quot;css/main.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&amp;gt;  
    &amp;lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=&quot;utf-8&quot;&amp;gt;  
 &amp;lt;/head&amp;gt;  
 &amp;lt;body&amp;gt;  
    ---------freemarker代码块  
 &amp;lt;/body&amp;gt;  
&amp;lt;/html&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;int&quot;&gt;12.使用内建的int获得整数部分&lt;/h3&gt;
&lt;p&gt;如&lt;code&gt;${1.1?int} = 1&lt;/code&gt;  &lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;13.比较操作符：&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;使用=（或==，完全相等）测试两个值是否相等，使用!= 测试两个值是否不相等。  &lt;/li&gt;
  &lt;li&gt;对数字和日期可以使用&amp;lt;、&amp;lt;=、&amp;gt;和&amp;gt;=，但不能用于字符串  &lt;/li&gt;
  &lt;li&gt;由于Freemarker会将&amp;gt;解释成FTL标记的结束字符，所以对于&amp;gt;和&amp;gt;=可以使用括号来避免这种情况，例如&lt;code&gt;&amp;lt;#if (x &amp;gt; y)&amp;gt;&lt;/code&gt;，另一种替代的方法是，使用&lt;code&gt;lt&lt;/code&gt;、&lt;code&gt;lte&lt;/code&gt;、&lt;code&gt;gt&lt;/code&gt;和&lt;code&gt;gte&lt;/code&gt;来替代&amp;lt;、&amp;lt;=、&amp;gt;和&amp;gt;=  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-4&quot;&gt;14.内建函数：&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;html：对字符串进行HTML编码  &lt;/li&gt;
  &lt;li&gt;cap_first：使字符串第一个字母大写  &lt;/li&gt;
  &lt;li&gt;lower_case：将字符串转换成小写  &lt;/li&gt;
  &lt;li&gt;upper_case：将字符串转换成大写  &lt;/li&gt;
  &lt;li&gt;trim：去掉字符串前后的空白字符  &lt;/li&gt;
  &lt;li&gt;size：获得序列中元素的数目  &lt;/li&gt;
  &lt;li&gt;int：取得数字的整数部分（如-1.9?int的结果是-1）  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-5&quot;&gt;15.将表达式结果转换成文本输出&lt;/h3&gt;
&lt;p&gt;根据缺省格式（由#setting指令设置）将表达式结果转换成文本输出；可以使用内建函数string格式化单个Interpolation&lt;br /&gt;
如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;#setting number_format=&quot;currency&quot;/&amp;gt;  
&amp;lt;#assign answer=42/&amp;gt;   输出结果是：$42.00   单个Interpolation：  

${answer?string.number}  
${answer?string.currency}  
${answer?string.percent}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-6&quot;&gt;16. 插入日期值：&lt;/h3&gt;
&lt;p&gt;根据缺省格式（由#setting指令设置）将表达式结果转换成文本输出；可以使用内建函数string格式化单个Interpolation&lt;br /&gt;
如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;${lastUpdated?string(&quot;yyyy-MM-dd HH:mm:ss zzzz&quot;)}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;session&quot;&gt;17.Session中设置对象属性的判断：&lt;/h3&gt;

   	Session [“userweb”].member?exists

&lt;h3 id=&quot;section-7&quot;&gt;18. 插入布尔值：&lt;/h3&gt;
&lt;p&gt;根据缺省格式（由#setting指令设置）将表达式结果转换成文本输出；可以使用内建函数string格式化单个Interpolation.&lt;br /&gt;
如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;#assign or=true/&amp;gt;  
${or?string(&quot;You are right!&quot;, &quot;You are wrong!&quot;)}   输出为：You are right!  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-8&quot;&gt;19. 格式化数字&lt;/h3&gt;
&lt;p&gt;数字Interpolation的#{expr; format}形式可以用来格式化数字，format可以是：  &lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;mX：小数部分最小X位  &lt;/li&gt;
  &lt;li&gt;MX：小数部分最大X位  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;#assign x=2.582/&amp;gt;  
&amp;lt;#assign y=4/&amp;gt;  
#{x; M2}   &amp;lt;#-- 2.58 --&amp;gt;  
#{y; M2}   &amp;lt;#-- 4    --&amp;gt;  
#{x; m1}   &amp;lt;#-- 2.6 --&amp;gt;  
#{y; m1}   &amp;lt;#-- 4.0 --&amp;gt;  
#{x; m1M2} &amp;lt;#-- 2.58 --&amp;gt;  
#{y; m1M2} &amp;lt;#-- 4.0 --&amp;gt;   
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-9&quot;&gt;20.用户定义指令：宏&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;#macro greet person&amp;gt;  
&amp;lt;font size=&quot;+2&quot;&amp;gt;Hello ${person}!&amp;lt;/font&amp;gt;  
&amp;lt;/#macro&amp;gt;    作为用户定义指令使用宏变量时，使用@替代FTL标记中的#  

&amp;lt;@greet person=&quot;Fred&quot;/&amp;gt; and &amp;lt;@greet person=&quot;Batman&quot;/&amp;gt;    输出为：Hello Fred! and Hello Batman!   
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-10&quot;&gt;21： 宏可以有多参数：&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;#macro greet person color&amp;gt;  
	&amp;lt;font size=&quot;+2&quot; color=&quot;${color}&quot;&amp;gt;Hello ${person}!&amp;lt;/font&amp;gt;  
&amp;lt;/#macro&amp;gt;   可以这样使用该宏变量：  

&amp;lt;@greet person=&quot;Fred&quot; color=&quot;black&quot;/&amp;gt; 其中参数的次序是无关的，只能使用在macro指令中定义的参数，并且对所有参数赋值，所以下面的代码是错误的：   只能使用在macro指令中定义的参数，并且对所有参数赋值，多了或者少了都会出错的，完全赋值。 如：`&amp;lt;@greet person=&quot;Fred&quot;/&amp;gt;`为错。  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以在定义参数时指定缺省值，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;#macro greet person color=&quot;black&quot;&amp;gt;  
	&amp;lt;font size=&quot;+2&quot; color=&quot;${color}&quot;&amp;gt;Hello ${person}!&amp;lt;/font&amp;gt;  
&amp;lt;/#macro&amp;gt;    这样`&amp;lt;@greet person=&quot;Fred&quot;/&amp;gt;`就正确了，宏的参数是局部变量，只能在宏定义中有效。  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-11&quot;&gt;22. 嵌套内容&lt;/h3&gt;
&lt;p&gt;用户定义指令可以有嵌套内容，使用&amp;lt;#nested&amp;gt;指令执行指令开始和结束标记之间的模板片  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;#macro border&amp;gt;  
	&amp;lt;table border=4 cellspacing=0 cellpadding=4&amp;gt;
		&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;&amp;lt;#nested&amp;gt;&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;
	&amp;lt;/table&amp;gt;  
&amp;lt;/#macro&amp;gt;    这样使用该宏变量：  
  
&amp;lt;@border&amp;gt;The bordered text&amp;lt;/@border&amp;gt;   输出结果：  

&amp;lt;table border=4 cellspacing=0 cellpadding=4&amp;gt;
	&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;The bordered text&amp;lt;/tr&amp;gt;&amp;lt;/td&amp;gt;
&amp;lt;/table&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;list&quot;&gt;23. list循环中索引值&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;item_index:这是一个包含当前项在循环中的步进索引的数值。&lt;/li&gt;
  &lt;li&gt;item_has_next:来辨别当前项是否是序列的最后一项的布尔值。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;code：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;#assign seq = [&quot;winter&quot;, &quot;spring&quot;, &quot;summer&quot;, &quot;autumn&quot;]&amp;gt; 
&amp;lt;#list seq as x&amp;gt;
	${x_index + 1}. ${x}&amp;lt;#if x_has_next&amp;gt;,&amp;lt;/#if&amp;gt; 
&amp;lt;/#list&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出结果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1. winter, 2. spring, 3. summer, 4. autumn
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>win8技巧知识扫盲</title>
   <link href="/win8/2012/10/28/use-win8-skills.html"/>
   <updated>2012-10-28T00:00:00+08:00</updated>
   <id>/win8/2012/10/28/use-win8-skills</id>
   <content type="html">
&lt;h2 id=&quot;win8&quot;&gt;50个win8实用技巧&lt;/h2&gt;

&lt;p&gt;windows 8操作系统相信大家已经不再陌生了，正式版已经正式发布，笔者这里汇总了50个win8技巧，希望对windows 8菜鸟朋友后期快速入手windows 8有所帮助。&lt;/p&gt;

&lt;h3 id=&quot;windows-8&quot;&gt;windows 8操作系统界面&lt;/h3&gt;
&lt;p&gt;由于windows 8不仅仅只是普通电脑操作系统，微软更看重的是平板电脑领域，因此很多东西比较兼顾触摸方向，因此初期很多朋友使用windows 8系统感觉没以前windows 7或windows xp系统那么习惯了，不过使用时间已久也就慢慢习惯了，下面进入正题吧。&lt;/p&gt;

&lt;h4 id=&quot;section&quot;&gt;1、锁屏&lt;/h4&gt;

&lt;p&gt;　启动之后，用户将首先看到 Windows 8的锁屏界面，每当系统启动、恢复或登录的时候，锁屏就会出现。如果您使用的是触摸屏设备，那么用手指一扫然后输入密码就可以登录系统。如果不是触摸屏设备，那么就用鼠标点击之后就能够登录系统。
　
####2、Metro 主屏&lt;/p&gt;

&lt;p&gt;　当用户登录 Windows 8系统之后，新的 Metro 启动屏幕就会出现，上面铺满了瓦片式的程序。当然了，如果您不喜欢某个应用程序，您也可以右击将其移除，然后按照自己的喜好重新排列应用程序的位置。
　
####3、简化的开始菜单
　
　Metro 用户界面具备自己的开始菜单，其中包含一些简单的选项，如设置、设备、共享和搜索等。&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;4、运行任何程序&lt;/h4&gt;
&lt;p&gt;　按住 Windows 键或者是 Win+F 就可以打来搜索窗口，键入程序的名称就可以打开指定的应用程序。
　
####5、任务切换
　Metro 屏幕不具备任务栏，因此用户很容易会找不到那些运行的应用程序，这种情况下，用户只需按住 Alt+Tab 键就能够查看正在运行的应用程序，而按住 Win+Tab 键则能够自一个正在运行的应用程序切换到下一个应用程序。&lt;/p&gt;

&lt;h4 id=&quot;section-2&quot;&gt;6、关闭应用程序&lt;/h4&gt;
&lt;p&gt;　Metro 应用程序不包含一个“关闭”按钮，其实这是微软的故意设计，当运行另外一个应用程序的时候，当前的应用程序就会被挂起，当资源不足时，系统就会自动关闭这个应用程序。当然了，用户也可以手动关闭应用程序，按住 Ctrl+Alt+Esc 就可打开任务管理器，右击多余的应用程序选择终止任务即可。&lt;/p&gt;

&lt;h4 id=&quot;section-3&quot;&gt;7、关闭系统&lt;/h4&gt;
&lt;p&gt;　如果想要在 Metro 界面中关闭系统，那么只需调出设置对话框，点击电源按钮，然后关闭即可。当然了，如果处于桌面状态，您也可以按住 Alt+F4，然后选择关闭、重启、切换用户或注销等选项。&lt;/p&gt;

&lt;h4 id=&quot;metro-internet-explorer&quot;&gt;8、Metro Internet Explorer&lt;/h4&gt;
&lt;p&gt;　点击 IE 的 Metro 窗格，一个全屏版的浏览器就会出现，它是一个触摸友好的浏览器，鼠标用户当然也有一些优势：右击即可将网站固定到 Metro 屏幕中，例如打开一个新的浏览器标签或切换到旧标签。当然了，如果您喜爱的是旧式 IE 界面，那么只需在桌面中启动 IE 浏览器即可，或者是按住 Windows 键再按 1 即可。&lt;/p&gt;

&lt;h4 id=&quot;section-4&quot;&gt;9、多屏显示&lt;/h4&gt;
&lt;p&gt;　正常情况下，Metro 应用程序是全屏运行的，但是如果您运行的是触摸屏设备，那么也可同时查看两个应用程序。&lt;/p&gt;

&lt;h4 id=&quot;section-5&quot;&gt;10、查询天气&lt;/h4&gt;
&lt;p&gt;　一般情况下，很多绑定的 Metro 应用程序都能够通过右击重新配置。默认情况下，天气应用程序是显示加利福尼亚州阿纳海姆市的天气，如果用户想要查看本地天气的话，只需右击选择添加城市，键入距离最近的城市名称即可。&lt;/p&gt;

&lt;h4 id=&quot;section-6&quot;&gt;11、拼写检查&lt;/h4&gt;
&lt;p&gt;　Metro 应用程序都具备拼写检查功能，与 Office 相似。一旦出现错误，违规词下方就会显示一个红色波浪下划线，右击就可看到建议的替代字词，用户还可以将这些字词添加到自己的字典中。&lt;/p&gt;

&lt;h4 id=&quot;section-7&quot;&gt;12、以管理员身份运行&lt;/h4&gt;
&lt;p&gt;　有些应用程序只有在管理员权限下方可运行，只需右击应用程序，点击“高级”，选择“以管理员身份运行”选项即可。&lt;/p&gt;

&lt;h4 id=&quot;section-8&quot;&gt;13、休眠或睡眠&lt;/h4&gt;
&lt;p&gt;　默认情况下，休眠或睡眠选项是不会出现在 Windows 8关闭对话框中的，但是用户可以恢复它们。启动电源选项程序(powercfg.cpl)，点击左侧窗格中的“选择电源按钮运行状况”，如果看到“更改当前不可用”的链接，点击它，选择“休眠或睡眠”选项，点击保存设置，此后“休眠或睡眠”选项就会出现在关闭对话框中。&lt;/p&gt;

&lt;h4 id=&quot;section-9&quot;&gt;14、自动登录&lt;/h4&gt;
&lt;p&gt;　厌倦手动登录 Windows 8?下面就是自动登录 Windows 8的方法：按住 Windows 键，按R，键入 netplwiz 然后按回车键启动用户账户对话框。清除“用户必须输入用户名和密码才能使用这台计算机”复选框，点击“确定”即可。&lt;/p&gt;

&lt;h4 id=&quot;windows-8-windows-&quot;&gt;15、Windows 8中的 Windows 快捷键&lt;/h4&gt;
&lt;p&gt;虽然 Windows Metro 用户界面主要是针对触摸屏设计的，但是它支持大多数的旧 Windows 快捷键。
Win + C ：显示 Charms，如设置、设备、共享和搜索等选项;
Win + D：启动桌面;
Win + E：启动资源管理器;
Win + F：打开搜索;
Win + I：打开设置;
Win + L：锁定您的电脑;
Win + P：将您的显示器切换到第二显示器或投影仪;
Win + R：打开运行框;
Win + U：打开轻松访问中心;
Win + W：搜索您的系统设置;
Win + Z：当打开一个全屏 Metro 应用程序时，显示右击上下文菜单;
Win + ：放大;
Win —：缩小;
更多» windows 8快捷键大全&lt;/p&gt;

&lt;h4 id=&quot;section-10&quot;&gt;16、快速启动应用程序&lt;/h4&gt;
&lt;p&gt;　如果您习惯使用键盘设备，不想要滚动去查找所需的应用程序，那么别担心，Windows 8还支持一个有用的老式快捷方式。
　打开桌面，启动媒体播放器，右击它的任务栏图标，选择固定这个程序到任务栏。关闭媒体播放器，拖动它的任务栏图标到最左边，与之任务栏按钮紧靠，然后再次按住 Windows 键切换到 Metro 用户界面。按住 Windows 键，按下1，您就会看到桌面出现，而媒体播放器也启动了。当然了，用户也可以按住 Windows+2 或 3 键去启动第二(默认是 IE)或第三个图标(默认是任务管理器)。&lt;/p&gt;

&lt;h4 id=&quot;section-11&quot;&gt;17、查看所有已安装的应用程序&lt;/h4&gt;
&lt;p&gt;　Windows 8中不再显示开始菜单，这意味着用户不能够轻易地看到系统中的所有非 Metro 应用程序。除非用户按住 Windows+F 键去查看搜索对话框，您将会看到一个按字母顺序排列的已安装应用程序列表，点击即可启动它。&lt;/p&gt;

&lt;h4 id=&quot;section-12&quot;&gt;18、关机快捷键&lt;/h4&gt;
&lt;p&gt;　最快速的关机方式就是通过一个合适的快捷方式，启动桌面应用程序，右击桌面上的空白部分，单击新建快捷方式。
　输入 shutdown.exe -s -t 00是关闭计算机;
　输入 shutdown.exe -h -t 00是休眠计算机;
　点击下一步，输入一个快捷方式名称，点击完成。&lt;/p&gt;

&lt;h4 id=&quot;section-13&quot;&gt;19、恢复“开始”菜单&lt;/h4&gt;
&lt;p&gt;　如果您不喜欢 Metro 用户界面，那么可以通过以下方式去恢复到一个更加传统的 Windows 外观：启动 REGEDIT (注册表)然后浏览至 HKEY_CURRENT_USERSoftwareMicrosoftWindowsCurrentVersionExplorer，双击 RPEnabled，然后将其参数值自 1 调为 0 去移除 Metro、新任务栏和新开始菜单等。另外，设置 RPEnabled 的参数值为 2 是移除 Metro，恢复开始菜单并且保留 Windows 8中大多数的其他改进。&lt;/p&gt;

&lt;h4 id=&quot;metro-&quot;&gt;20、自桌面启动 Metro 应用程序&lt;/h4&gt;
&lt;p&gt;　将大多数时间花在桌面上并不意味着放弃 Metro 应用程序，在桌面中创建一个名为“应用程序”的文件夹，然后打开它就会发现 Metro 屏幕中的每个应用程序图标以及其他的 Windows 小程序。如果您想要打开一个特定的 Metro 应用程序，那么打开这个文件夹，双击这个应用程序的图标即可。
　Win + Tab：在打开的应用程序之间切换。&lt;/p&gt;

&lt;h4 id=&quot;usb--windows-8&quot;&gt;21、USB 闪存驱动器安装 Windows 8&lt;/h4&gt;
&lt;p&gt;　如果您想要用USB 闪存驱动器安装 Windows 8操作系统，而不是 DVD，那么 Windows 7 USB/DVD 下载工具可以帮助您。用户可以将 Windows 7 USB/DVD 下载工具指向 Windows 8 ISO 文件，然后它就能够在 USB 驱动器上创建一个可启动的 Windows 8安装程序。&lt;/p&gt;

&lt;h4 id=&quot;smartscreen&quot;&gt;22、SmartScreen&lt;/h4&gt;
&lt;p&gt;　Windows 8全系统都使用 IE 的 SmartScreen 安全功能，检查下载文件去确保它们的安全。但是，如果用户不想要 SmartScreen 功能的话，那么也可以对其进行调整，按住 Windows+R 键，键入 control.exe，回车启动旧式控制面板。打开行动中心面板，点击更改 SmartScreen 设置，这样一来，用户就可以开启警告，但是避免打扰到自己，或者是直接关闭 SmartScreen 功能。23、64位 IE如果您使用的是 64 位 Windows 8，那么它的 IE 副本运行的也是 64 位模式，不过需要用户手动开启。点击工具互联网选项安全，选择您想要调整的安全区域，选中启动 64 位模式，点击确定，重启即可。&lt;/p&gt;

&lt;h4 id=&quot;section-14&quot;&gt;24、虚拟机器&lt;/h4&gt;
&lt;p&gt;　安装 Windows 8之后，您还可获得微软的 Hyper-V虚拟功能，它允许您创建和运行虚拟机器。启动 OptionalFeatures.exe，检查 Hyper-V，然后点击确定去启用 Hyper-V功能。切换到 Metro 用户界面，滑动到右侧的 Hyper-V瓦片去开始探索这个功能。&lt;/p&gt;

&lt;h4 id=&quot;section-15&quot;&gt;25、早期推出反恶意软件功能&lt;/h4&gt;
&lt;p&gt;　当 Windows 8系统启动之后，它能够选择性地决定初始化哪个驱动程序、拒绝加载可疑或未知的驱动程序去保证您的计算机免受感染。不过，用户需要手动去启动这个反恶意软件功能，启动 GPEDIT.MSC，浏览至计算机配置管理模板系统早期启动恶意软件，双击右侧启动初始化驱动程序安装策略，选择您想要的选项即可。
　当然了，笔者需要提醒大家的是，如果这个反恶意软件不小心阻止了一个合法驱动程序的话，那么您的系统可能会崩溃。&lt;/p&gt;

&lt;h4 id=&quot;windows-8-1&quot;&gt;26、Windows 8文件历史记录&lt;/h4&gt;
&lt;p&gt;　Windows 8包含一个很好的文件历史功能，它能够备份任何用户选定的文件。&lt;/p&gt;

&lt;h4 id=&quot;usb-&quot;&gt;27、USB 驱动器&lt;/h4&gt;
&lt;p&gt;　将 USB 驱动器连接到 Windows 8系统中，自菜单中选择“配置这个驱动器去备份使用的文件历史”，默认情况下，用户的库、联系人、收藏夹和桌面内容将会被立即备份。&lt;/p&gt;

&lt;h4 id=&quot;section-16&quot;&gt;28、控制面板&lt;/h4&gt;
&lt;p&gt;　当点击新的 Metro 控制面板瓦片的时候，Windows 8自定义的过程就开始了。例如，点击个性化，您就可以更改您的锁屏图片;点击屏幕顶部的“用户”瓦片，您就可以更改代表您账户的图片。&lt;/p&gt;

&lt;h4 id=&quot;section-17&quot;&gt;29、图片密码&lt;/h4&gt;
&lt;p&gt;　Windows 8允许用户创建图片密码，选择一个图片，然后在上面拖动绘制出波浪线、直线和圆圈组合，此后，只有能够重现此模式的人才能够登录系统。
　点击控制面板用户创建一个图片密码。&lt;/p&gt;

&lt;h4 id=&quot;section-18&quot;&gt;30、简化搜索&lt;/h4&gt;
&lt;p&gt;　在默认情况下，Windows 8在其搜索结果中包含每一个绑定的应用程序，如果您不想看到某些应用程序，那么点击 Metro 屏幕上的控制面板，选择搜索，选择不想看到的应用程序。这样一来，用户的列表将会更加易于管理。&lt;/p&gt;

&lt;h4 id=&quot;section-19&quot;&gt;31、触摸式键盘&lt;/h4&gt;
&lt;p&gt;　在默认情况下，触摸式键盘是对用户来讲是非常有益的，例如在用户键入的时候播放声音，将每句话开头的第一个字母自动调整为大写，双击空格键的时候留出空间等。如果其中某个功能是您不喜欢的话，那么进入控制面板自定义键盘去满足您的需求。&lt;/p&gt;

&lt;h4 id=&quot;section-20&quot;&gt;32、选择性地同步&lt;/h4&gt;
&lt;p&gt;　Windows 8能够跨越每个系统去同步设置，这听起来不错，但是却很容易导致隐私问题，它会同步互联网历史、密码等。如果这个不符合您的需求的话，那么您可以自 Metro 控制面板去自定义同步，点击同步 PC 设置，并选择您中意的选项。&lt;/p&gt;

&lt;h4 id=&quot;section-21&quot;&gt;33、完整的控制面板&lt;/h4&gt;
&lt;p&gt;　按住 Windows+R 键，键入 Control.exe 并按下回车，能够直接打开一个完整的控制面板。&lt;/p&gt;

&lt;h4 id=&quot;windows-8-2&quot;&gt;34、Windows 8资源管理器&lt;/h4&gt;
&lt;p&gt;　如今，Windows 8资源管理器中包含一个 Ribbon 用户界面。&lt;/p&gt;

&lt;h4 id=&quot;ribbon&quot;&gt;35、隐藏 Ribbon&lt;/h4&gt;
&lt;p&gt;　如果您觉得 ribbon 占用了太大的空间，以下就是隐藏 ribbon 的方法：按住 Windows+R 键，输入 gpedit.msc 按回车，点击计算机配置管理模板 Windows 组件 Windows 资源管理器区。双击“最小化 ribbon 启动 Windows 资源管理器”，启用这个功能即可。&lt;/p&gt;

&lt;h4 id=&quot;section-22&quot;&gt;36、快速访问工具栏&lt;/h4&gt;
&lt;p&gt;　最新的资源管理器包含一个快速访问工具栏功能，使得用户能够简易地访问“新建文件夹”、“最小化”以及“撤销删除”等选项。&lt;/p&gt;

&lt;h4 id=&quot;section-23&quot;&gt;37、磁盘错误检查&lt;/h4&gt;
&lt;p&gt;　当检查驱动器错误的时候，Windows 8还提供了一个额外的选项，一个是“扫描驱动器”选项，另外一个就是新的“扫描和修复”选项，能够修复计算机中所存在的问题。&lt;/p&gt;

&lt;h4 id=&quot;section-24&quot;&gt;38、改进的文件复制&lt;/h4&gt;
&lt;p&gt;　在资源管理器中复制文件，用户将能够看到一个增强的对话框，其中提供更多信息，如果有问题，用户可以点击暂停按钮中止一段时间。如果有冲突的话，那么用户可以自己决定保留或取消哪些文件。&lt;/p&gt;

&lt;h4 id=&quot;windows-8-mount-iso-&quot;&gt;39、在 Windows 8中 Mount ISO 文件&lt;/h4&gt;
&lt;p&gt;　想要细看一个 ISO 文件?右击资源管理器，点击 Mount 然后就可查看一个虚拟驱动器，用户可以打开其中包含的文件或添加更多的文件。&lt;/p&gt;

&lt;h4 id=&quot;windows-8-3&quot;&gt;40、Windows 8文件夹选项&lt;/h4&gt;
&lt;p&gt;　Windows 8的文件夹选项又有了新的变化，工具栏菜单不见了，但是如果用户点击文件改变文件夹和搜索选项的话，旧式的对话框就会出现。当然了，用户也可以自旧式的控制面板去加载文件夹选项：按住 Windows+R 键，输入 Control.exe 然后按回车去启动控制面板，选择视图列表中的大图标，然后点击文件夹选项去打开对话框。&lt;/p&gt;

&lt;h4 id=&quot;section-25&quot;&gt;41、打开一个新进程&lt;/h4&gt;
&lt;p&gt;　Windows 8的资源管理器看起来更稳定，不过一旦出现崩溃的话，用户可以通过以下步骤去打开它们：点击文件打开新窗口在新进程中打开新窗口，资源管理器将会在单独的 Explorer.exe 进程中运行新窗口。&lt;/p&gt;

&lt;h4 id=&quot;section-26&quot;&gt;42、重启资源管理器&lt;/h4&gt;
&lt;p&gt;　如果 Windows 8的资源管理器由于某些原因而锁定了，那么用户是不需要关闭资源管理器再重启的，只需按住 Ctrl+Alt+Esc，在列表中选择资源管理器然后再点击重启即可。&lt;/p&gt;

&lt;h4 id=&quot;section-27&quot;&gt;43、虚拟安装问题&lt;/h4&gt;
&lt;p&gt;　如果在虚拟机器中安装 Windows 8的话，那么您很有可能会遇到一些问题，例如 VMware Workstation 7无法顺利完成任务，而微软自己的虚拟 PC 和虚拟服务器也运行失败。在此，用户的最佳选择就是运行最新版本的 VirtualBox，Mac 上的 VMware Workstation 8和 Parallels 7也可正常工作。&lt;/p&gt;

&lt;h4 id=&quot;section-28&quot;&gt;44、解决性能问题&lt;/h4&gt;
&lt;p&gt;　如果您的 Windows 8系统运行缓慢，但又不知道是何原因的话，那么新的任务管理器很有可能帮助您解决问题。按住 Ctrl+Shift+Esc 或右击任务栏并选择启动任务管理器去启动新版的任务管理器，进程选项卡会为您显示当前使用 CPU 时间、内存、硬盘驱动器和网络带宽的详细视图，性能选项卡会为您显示资源使用的图形视图，而应用程序历史对话框则会为您显示哪个应用程序是最消耗资源的。&lt;/p&gt;

&lt;h4 id=&quot;metro--1&quot;&gt;45、Metro 应用程序无法启动&lt;/h4&gt;
&lt;p&gt;　如果您点击一个 Metro 应用程序，但是它却无法启动的话，这可能是因为显示问题。据悉，Metro 应用程序当前是不支持低于 1024x768 的屏幕分辨率的，因此您应该尽可能地增加您的屏幕分辨率。如果还是不行的话，那么就更新您的视频驱动器。此外，用户账户问题也是常见的导致 Metro 应用程序无法启动的原因，尝试通过不同的电子邮件地址去创建一个新的用户账户。&lt;/p&gt;

&lt;h4 id=&quot;section-29&quot;&gt;46、旧的任务管理器&lt;/h4&gt;
&lt;p&gt;　如果新版任务管理器不符合您的需求的话，您可以按住 Windows+R 键，然后输入 TaskMGR 按回车去启动旧的任务管理器。&lt;/p&gt;

&lt;h4 id=&quot;section-30&quot;&gt;47、16位应用程序&lt;/h4&gt;
&lt;p&gt;　打开桌面控制面板，打开 16 位应用程序支持小应用程序，并点击确定即可在 Windows 8中运行古老的 16 位应用程序。&lt;/p&gt;

&lt;h4 id=&quot;windows-8-4&quot;&gt;48、Windows 8崩溃&lt;/h4&gt;
&lt;p&gt;　当 Windows 8出现蓝屏崩溃情况的时候，就会出现以下画面。&lt;/p&gt;

&lt;h4 id=&quot;section-31&quot;&gt;49、设备管理器事件&lt;/h4&gt;
&lt;p&gt;　如果您在 Windows 8中遇到一个驱动器或硬件相关的问题，那么启动设备管理器，浏览至相关的设备，右击它，然后选择属性和点击新的事件标签，您就可以看到 Windows 所安装的驱动器、相关服务等。&lt;/p&gt;

&lt;h4 id=&quot;windows-8-5&quot;&gt;50、修复 Windows 8&lt;/h4&gt;
&lt;p&gt;　如果 Windows 8停止工作的话，那么下面有几种新的方法去使 Windows 8恢复正常工作。如果 Windows 8能够启动，选择 Metro 控制面板应用程序，点击“常规”选择“刷新”选项去重新安装 Windows 并同时保留您的数据，如果选择“重置”选项的话，那么就可以恢复 Windows 并同时删除您的数据和应用程序。
　如果 Windows 8无法启动的话，那么就自您的原始安装光盘中启动，选择语言和键盘，点击“修复您的计算机”然后选择“疑难解答”，此后您就可以重新安装或重置您的计算机。单击“高级”选项，您将会看到自之前的还原点去恢复 Windows 的工具或系统镜像文件以及一个“自动修复”选项去解决 Windows 中的常见启动问题。
　&lt;/p&gt;

&lt;h3 id=&quot;section-32&quot;&gt;总结　&lt;/h3&gt;
&lt;p&gt;好了以上就是编辑为大家推荐的50个windows8应用技巧，当然win8技巧也远远不止这些，这些都需要我们慢慢去接触，去尝试才可以发现与挖掘，如果您对windows 8不熟悉的话，相信阅读完本文你会有一定收获！&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>javascript高级特性学习笔记</title>
   <link href="/javascript/2012/10/26/javascript-essence.html"/>
   <updated>2012-10-26T00:00:00+08:00</updated>
   <id>/javascript/2012/10/26/javascript-essence</id>
   <content type="html">
&lt;h2 id=&quot;javascript&quot;&gt;javascript高级特性学习笔记&lt;/h2&gt;

&lt;h3 id=&quot;section&quot;&gt;编程理念:&lt;/h3&gt;
&lt;p&gt;面向对象、函数式编程、闭包、动态绑定、作用域&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;1、作用域&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;概念：&lt;/strong&gt;
命名冲突、函数作用域&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;搜索顺序：&lt;/strong&gt;
局域作用域-&amp;gt;上层作用域-&amp;gt;全局作用域&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;全局对象：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在Node.js对应的是global对象&lt;/li&gt;
  &lt;li&gt;在浏览器中对应的是window对象&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;全局作用域：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;最外层定义的变量，如 &lt;code&gt;var global;&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;全局对象的属性，如&lt;code&gt;$.util.pagin&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;任何地方隐式定义的变量（未定义直接赋值），如&lt;code&gt;global=&quot;aaa&quot;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-2&quot;&gt;2、闭包&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;定义：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当一个函数返回它内部定义的一个函数时，就产生了一个闭包。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;code：&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var generateClosure = function(){
	var count = 0;
	var get = function(){
		count ++;
		return count;
	};
	return get;
};
var counter1 = generateClosure();
var counter2 = generateClosure();

console.log(counter1());//1
console.log(counter2());//1
console.log(counter1());//2
console.log(counter1());//3
console.log(counter2());//2 **结论：**
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;调用函数时，生成两个闭包实例，在内存中生成了相互独立的副本，它们内部引用的count变量分别属于各自的运行环境。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;用途：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;嵌套的回调函数&lt;/li&gt;
  &lt;li&gt;实现js对象私有成员，防止被外部调用时修改破坏，按非正式约定需加下划线前缀。此处模拟方式：把一个对象用闭包封装起来，只返回一个“访问器”的对象，即可实现对细节隐藏。	&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-3&quot;&gt;3、对象&lt;/h3&gt;

&lt;h3 id=&quot;section-4&quot;&gt;什么是前端，前端的意义&lt;/h3&gt;
</content>
 </entry>
 
 <entry>
   <title>javascript面向对象编程浅析</title>
   <link href="/javascript/2012/09/20/oop.html"/>
   <updated>2012-09-20T00:00:00+08:00</updated>
   <id>/javascript/2012/09/20/oop</id>
   <content type="html">
&lt;h3 id=&quot;section&quot;&gt;什么是面向对象&lt;/h3&gt;
&lt;p&gt;面向对象最基本的三大特性是继承、封装、多态，javascript不是面向对象的语言，但能实现继承和封装两个特性。
js中的对象&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;弱类型&lt;/h3&gt;

&lt;p&gt;定义变量类型：&lt;/p&gt;

&lt;p&gt;布尔型bool、数值型、字符串类型、函数类型、数组类型、空类型、未定义类型&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var a = &quot;&quot;; //字符串
var b = []; //数组
var c = function(){} //function函数
var d = {}; //对象
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;字面量:&lt;/p&gt;

&lt;p&gt;字面量就类似于我们使用的json数据格式，分为字符串字面量、数组字面量、函数字面量、对象字面量。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var cat = {
	//字符串字面量
	name : &quot;cat&quot;,
	
	//数组字面量
	type : [&quot;波斯猫&quot;, &quot;加菲猫&quot;, &quot;垂耳猫&quot;],
	
	//函数字面量
	mark : function(){alert(this.name + this.type)},
	
	//对象字面量
	info : {from : &quot;usa&quot;, &quot;age&quot; : &quot;1&quot;}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;js&quot;&gt;创建js对象&lt;/h3&gt;
&lt;p&gt;js对象只是一组名称/值对，可以使用熟悉的“.”（点）运算符或“[]”运算符，来获得和设置对象的属性，像词典。&lt;/p&gt;

&lt;p&gt;code1：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var userObject = new Object();
userObject.lastLoginTime = new Date();
alert(userObject.lastLoginTime); 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code2：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var userObject = {}; // equivalent to new Object()
userObject[&quot;lastLoginTime&quot;] = new Date();
alert(userObject[&quot;lastLoginTime&quot;]);   
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code3：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var userObject = { 
	&quot;lastLoginTime&quot; : new Date() 
};
alert(userObject.lastLoginTime);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;js-1&quot;&gt;创建js函数，函数也是对象&lt;/h3&gt;

&lt;p&gt;code：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//1、普通函数
function func(x) {
    alert(x);
}
func(&quot;blah&quot;);

//2、定义函数，在此创建函数对象，并赋给变量func
var func = function(x) {
    alert(x);
};
func(&quot;blah2&quot;);

//3、用Funciton构造函数，不常用
var func = new Function(&quot;x&quot;, &quot;alert(x);&quot;);
func(&quot;blah3&quot;);	
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-2&quot;&gt;使用对象初始化器创建对象&lt;/h3&gt;
&lt;p&gt;code1：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var myConstructor = function(){
}

//添加静态属性
//name属性和alertName()方法作为静态成员添加到了对象实例中
myConstructor.name = &quot;heiniu&quot;;
myConstructor.alertName = function(){
	alert(this.name);
}
//执行,不需要new
myConstructor.alertName();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code2：等价于以下代码，结构更简洁清晰。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//name属性和alertName()方法作为静态成员添加到了对象实例中
var myConstructor = {
	//静态属性
	name : &quot;heiniu&quot;,
	
	//静态方法
	alertName : function(){
		alert(this.name);
	}
}

//执行,不需要new
myConstructor.alertName(); **总结：**
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;优点：简洁明了；&lt;/li&gt;
  &lt;li&gt;缺点：创建对象的代码是一次性的&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-3&quot;&gt;使用构造函数创建对象&lt;/h3&gt;

&lt;p&gt;定义构造函数，而不是类&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//私有成员就是在构造函数中定义的变量和函数
function myConstructor2(msg, name){

	//公有属性
	this.myMsg = msg;
	this.name = name;
	
	//私有属性
	var myVersion = &quot;1.0&quot; 
	
	//私有方法
	function alertMsg(){
		alert(this.myMsg)
		alert(myVersion)
	}
	alertVersion();//实例化时显示信息
	
	//特权方法，也是公用方法，在构造函数的作用域中使用this关键字定义的方法，尽量不要用，只用于需要访问私有成员的情况。
	this.appendToMsg = fucntion(string){
		this.myMsg += &quot;heiniu_&quot; + string;
		alertMsg();
	}
	
}

//静态属性和方法，静态成员是直接通过类对象访问的。
myConstructor2.myYear = &quot;2012&quot;;
myConstructor2.now = function(){
	return new Date();
}

//公有方法，修改函数原型，即prototype属性。
//一旦修改原型方法则立即应用到继承的对象和实例中，有风险。
//原型方式会将新方法添加到myConstructor2的底层定义中，而不是myConstructor2实例自身。
myConstructor2.prototype.alertMsg(){
	alert(this.myMsg);
}
myConstructor2.prototype.alertName(){
	alert(this.name);
}

var myObj = new myConstructor2(&quot;hello&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;new操作符等价于&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//1、call()方法,每个函数对象都有一个名为 call 的方法，它将函数作为第一个参数的方法进行调用。第一个参数用作 this 的对象。其他参数都直接传递给函数自身。
var myObj = {};
myConstructor2.call(myObj,&quot;hello&quot;, &quot;heiniu&quot;)

//2、apply()方法，有两个参数，用作 this 的对象和要传递给函数的参数的数组。
var myObj = {};
myConstructor2.apply(myObj,[&quot;hello&quot;, &quot;heiniu&quot;])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;call的工作机制：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var someuser = {
	name : &quot;sjm&quot;,
	display : function(words){
		console.log(this.name + &#39; says &#39; + words);
	}
};

var myself = {
	name : &quot;heiniu&quot;
};

someuser.display.call(myself, &#39;fighting!&#39;);
//结果：heiniu says fighting!
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;someuser.display是函数的引用，即被调用的函数。&lt;/li&gt;
  &lt;li&gt;myself是someuser.display被调用时的上下文对象。&lt;/li&gt;
  &lt;li&gt;‘fighting!’是传入someuser.display的参数。&lt;/li&gt;
  &lt;li&gt;通过call将上下文对象改变为myself对象。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;作为对象，函数还可以赋给变量、作为参数传递给其他函数、作为其他函数的值返回，并可以作为对象的属性或数组的元素进行存储等等。&lt;/p&gt;

&lt;p&gt;call和apply的功能一致：以不同的对象作为上下文来调用某个函数，即允许一个对象去调用另一个对象的成员函数。&lt;/p&gt;

&lt;p&gt;call和apply的差别：call以参数表来接受被调用函数的参数，而apply以数组来接受被调用函数的参数。&lt;/p&gt;

&lt;p&gt;使用不同的引用来调用同一个函数时，this指针永远是这个引用所属的对象。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;优点：可创建出多个规划好的对象，有若干个固定的属性、方法，并能初始化实例化。&lt;/li&gt;
  &lt;li&gt;缺点：复杂些，有上下文对象（this指针），即被调用函数所处的环境。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-4&quot;&gt;使用原型和构造函数共同生成对象&lt;/h3&gt;
&lt;p&gt;什么是原型链？&lt;/p&gt;

&lt;p&gt;继承方面,javascript中的每个对象都有一个内部私有的链接指向另一个对象 (或者为 null),这个对象就是原对象的原型. 这个原型也有自己的原型, 直到对象的原型为null为止. 这种一级一级的链结构就称为原型链.&lt;/p&gt;

&lt;p&gt;prototype 对象的任何属性和方法都被传递给那个类的所有实例。原型链利用这种功能来实现继承机制。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function ClassA() {
}

ClassA.prototype.color = &quot;blue&quot;;
ClassA.prototype.sayColor = function () {
    alert(this.color);
};

function ClassB() {
}

//继承和扩展
ClassB.prototype = new ClassA();
ClassB.prototype.name = &quot;&quot;;
ClassB.prototype.sayName = function () {
    alert(this.name);
};

//执行
var objA = new ClassA();
var objB = new ClassB();
objA.color = &quot;blue&quot;;
objB.color = &quot;red&quot;;
objB.name = &quot;John&quot;;
objA.sayColor();
objB.sayColor();
objB.sayName();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用原型与直接在构造函数内定义的属性 不同点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;构造函数内定义的属性继承方式与原型不同，子对象需要显示调用父对象才能继承构造函数内定义的属性。&lt;/li&gt;
  &lt;li&gt;构造函数内定义的任何属性，包括函数在内都会被重复创建，同一个构造函数产生的两个对象不共享实例。&lt;/li&gt;
  &lt;li&gt;构造函数内定义的函数有运行时闭包的开销，因为构造函数内的局部变量对其中定义的函数来说是可见的。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;原型使用场合：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;除非必须用构造函数闭包，否则尽量用原型定义成员函数，可减少开销&lt;/li&gt;
  &lt;li&gt;尽量在构造函数内定义一般成员，尤其是对象或数组，因为用原型定义的成员是多个实例共享的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-5&quot;&gt;原型链机制：&lt;/h3&gt;

&lt;p&gt;javascript分为三类对象：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1、用户创建的对象&lt;/li&gt;
  &lt;li&gt;2、构造函数对象&lt;/li&gt;
  &lt;li&gt;3、原型对象&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;code：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Foo(){
}
var foo = new Foo();
var obj = new Object();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关系图如下：
&lt;img src=&quot;/images/prototype-1024x702.png&quot; alt=&quot;原型链关系图&quot; title=&quot;原型链关系图&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-6&quot;&gt;公有、私有、特权、静态总结&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;私有和特权成员在函数的内部，他们会被带到函数的每一个实例中生成新的副本，因而将占用大量的内存。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;公有的原型成员是对象的一部分，适用于通过new关键字实例化该对象的每一个实例。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;静态成员所关联的是类本身，而不同的是大多数方法和属性所关联的是类的实例。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;私有成员命名规范上用下划线表示，私有成员可避免安全隐患，防止使用者修改某个属性，导致对象内部数据的一致性受到破坏。如&lt;code&gt;_myPrivateProp&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-7&quot;&gt;参考&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://msdn.microsoft.com/zh-cn/magazine/cc163419.aspx&quot;&gt;http://msdn.microsoft.com/zh-cn/magazine/cc163419.aspx&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.w3school.com.cn/js/pro_js_inheritance_implementing.asp&quot;&gt;http://www.w3school.com.cn/js/pro_js_inheritance_implementing.asp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
 </entry>
 
 <entry>
   <title>IE盒模型与W3C盒模型浅总结</title>
   <link href="/css/2012/09/09/css-box-model.html"/>
   <updated>2012-09-09T00:00:00+08:00</updated>
   <id>/css/2012/09/09/css-box-model</id>
   <content type="html">
&lt;p&gt;css:层叠样式表（Cascading Style Sheets）&lt;/p&gt;

&lt;h3 id=&quot;demo&quot;&gt;demo：&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://www.heiniuhaha.com/demo/css-box-model/css-box-model-W3C.html&quot;&gt;http://www.heiniuhaha.com/demo/css-box-model/css-box-model-W3C.html&lt;/a&gt; 声明doctype&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://www.heiniuhaha.com/demo/css-box-model/css-box-model-IE.html&quot;&gt;http://www.heiniuhaha.com/demo/css-box-model/css-box-model-IE.html&lt;/a&gt; 不声明doctype&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;code ：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;style&amp;gt; 
	div{
		background-color:red;
		width:300px;
		height:300px;
		padding:20px;
		margin:100px;
		border:10px solid #000;
	}
	/*ie6不支持透明transparent*/
	.box2{border-color:transparent}
&amp;lt;/style&amp;gt;

&amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;div class=&quot;box2&quot;&amp;gt;&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;chrome测试图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.heiniuhaha.com/demo/css-box-model/css-box-model-chrome.png&quot; alt=&quot;chrome测试图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;IE6测试图-IE盒模型和W3C标准盒模型对比图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.heiniuhaha.com/demo/css-box-model/box-ie6.png&quot; alt=&quot;IE6测试图-标准和非标准&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;盒模型示意图&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;ie&quot;&gt;IE盒模型&lt;/h4&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://www.heiniuhaha.com/demo/css-box-model/p2.gif&quot; alt=&quot;IE盒模型&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;w3c&quot;&gt;W3C标准盒模型&lt;/h4&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://www.heiniuhaha.com/demo/css-box-model/p3.gif&quot; alt=&quot;W3C标准盒模型&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;总结：&lt;/h3&gt;

&lt;p&gt;IE盒模型占总空间=contentWidth，内容区只占了一小部分空间；&lt;/p&gt;

&lt;p&gt;w3c标准盒模型占总空间=contentWidth+padding+margin+border；&lt;/p&gt;

&lt;p&gt;同时：div的背景颜色充满了padding和border区域，border透明时，可发现背景颜色就是div的bgcolor.（ie6不支持透明transparent）&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;触发盒模型&lt;/h3&gt;
&lt;p&gt;IE6 IE7 IE8 IE9 在Quirks怪异模式下，盒模型是一模一样的，都是IE盒模型，即总width=width;&lt;/p&gt;

&lt;p&gt;IE6 IE7 IE8 IE9 在标准模式下，盒模型也是一模一样的，都是W3C盒模型， 即总width=width+padding+border;&lt;/p&gt;

&lt;p&gt;非IE下的浏览器，如FF、chrome都采用标准模式渲染，都是W3C盒模型， 即总width=width+padding+border;&lt;/p&gt;

&lt;h3 id=&quot;border&quot;&gt;border区域是否填充背景色&lt;/h3&gt;
&lt;p&gt;border区域不填充背景色图&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.heiniuhaha.com/demo/css-box-model/border-transparent-ie7.png&quot; alt=&quot;border区域不填充背景色&quot; /&gt;&lt;/p&gt;

&lt;p&gt;border区域填充背景色图&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.heiniuhaha.com/demo/css-box-model/border-transparent-ie8.png&quot; alt=&quot;border区域填充背景色&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-3&quot;&gt;标准模式下&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;非IE浏览器下，div的背景颜色充满了padding和border。border透明时，可发现border区域填充了背景色。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;IE8和IE9在标准模式下，和非IE浏览器渲染一致，border区域填充背景色；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;IE6 IE7标准模式下，border区域不填充背景色；&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-4&quot;&gt;非标准模式下&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;IE6 IE7 IE8 IE9在Quirks怪异模式下，border区域都不会填充背景色；&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-5&quot;&gt;备注：&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&amp;lt;!DOCTYPE&amp;gt; is not an HTML tag. It is an information (a declaration) to the browser about what version the HTML is written in. 声明帮助浏览器正确地显示网页。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;HTML规定了三种文档类型：Strict、Transitional 以及 Frameset。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在没有声明doctype的情况下，浏览器选择自己的模式，怪异模式(QUICK MODE)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-6&quot;&gt;参考&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.w3schools.com/css/css_boxmodel.asp&quot;&gt;w3schools.com css box model&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/ncode/article/details/7428746&quot;&gt;IE6与W3C标准的盒模型差异&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
 </entry>
 
 <entry>
   <title>seajs模块依赖的加载处理</title>
   <link href="/seajs/2012/08/26/seajs-require-theory.html"/>
   <updated>2012-08-26T00:00:00+08:00</updated>
   <id>/seajs/2012/08/26/seajs-require-theory</id>
   <content type="html">
&lt;h3 id=&quot;seajs&quot;&gt;seajs模块依赖问题&lt;/h3&gt;
&lt;p&gt;最近在做项目的时候发现一些关于模块依赖问题，特记录下:&lt;/p&gt;

&lt;p&gt;比如现有3个文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/*init.js*/
define(function(require, exports, module){
	require(&#39;jquery&#39;);
	require(&#39;jquery.plugA&#39;);
})

/*jquery.plugA.js*/
define(function(require, exports, module){
	require(&#39;jquery&#39;);
	require(&#39;jquery.plugB&#39;);
	//code...
})

/*jquery.plugB.js*/
define(functioin(require, exports, module){
	require(&#39;jquery&#39;);
	//code...
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;比如执行init.js时，init.js、jquery.plugA.js、jquery.plugB.js都会依赖到jquery，那么这种情况下seajs对jquery如何处理的呢？只执行一次？执行多次？还是其他方式？&lt;/p&gt;

&lt;p&gt;此处参考玉伯的回答：
&amp;gt;我对模块调用的理解是，调用是指获取某个模块的接口。在 SeaJS 里，只有 seajs.use, require.async, 和 require 会产生
模块调用，比如：
&lt;code&gt;var a = require(&#39;./a&#39;)&lt;/code&gt;
在执行 require(‘./a’) 时，会获取模块的接口，如果是第一次调用，会初始化模块 a，以后再调用时，直接返回模块 a 的接口
define 只是注册模块信息，比如打包之后：
&lt;code&gt;define(id, deps, factory)&lt;/code&gt;
是注册了一个模块到 seajs.cache 中，define 类似：
&lt;code&gt;seajs.cache[id] = { id: id, dependencies: deps, factory: factory }&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;是纯注册信息。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;而 &lt;code&gt;require(&#39;./a&#39;)&lt;/code&gt; 时，才会执行 &lt;code&gt;seajs.cache[&#39;a&#39;].factory&lt;/code&gt;, 执行后得到 &lt;code&gt;seajs.cache[&#39;a&#39;].exports&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;

&lt;/blockquote&gt;

&lt;h3 id=&quot;uriurl&quot;&gt;扩展：URI与URL的区别&lt;/h3&gt;
&lt;p&gt;URI:Uniform Resource Identifiers ，统一资源标识符；&lt;/p&gt;

&lt;p&gt;URL:Uniform Resource Locators ，统一资源定位符；&lt;/p&gt;

&lt;p&gt;URN:Uniform Resource Names，统一资源名称&lt;/p&gt;

&lt;p&gt;URL,URN是URI的子集.&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;参考&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Module.STATUS的具体含义：&lt;a href=&quot;https://github.com/seajs/seajs/issues/303&quot;&gt;https://github.com/seajs/seajs/issues/303&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;分清 URI、URL 和 URN&lt;a href=&quot;http://www.ibm.com/developerworks/cn/xml/x-urlni.html&quot;&gt;http://www.ibm.com/developerworks/cn/xml/x-urlni.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
 </entry>
 
 <entry>
   <title>【转】jQuery 模块介绍与 jQuery 插件的深度模块化</title>
   <link href="/seajs/2012/08/15/seajs-jquery-plugin.html"/>
   <updated>2012-08-15T00:00:00+08:00</updated>
   <id>/seajs/2012/08/15/seajs-jquery-plugin</id>
   <content type="html">
&lt;p&gt;转自玉伯 &lt;a href=&quot;http://lifesinger.wordpress.com/2011/08/19/jquery-introduction-and-plugins-modulization/&quot;&gt;jQuery 模块介绍与 jQuery 插件的深度模块化&lt;/a&gt;,方便不能翻墙的同学查看。
##jQuery模块
大名鼎鼎的 jQuery 就不多介绍了，详细介绍推荐官网：jquery.com
阮一峰最近整理的文章也不错，推荐：&lt;a href=&quot;http://www.ruanyifeng.com/blog/2011/07/jquery_fundamentals.html&quot;&gt;jQuery 设计思想&lt;/a&gt;, &lt;a href=&quot;http://www.ruanyifeng.com/blog/2011/08/jquery_best_practices.html&quot;&gt;jQuery 最佳实践&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;几点感悟：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;jQuery 是 DOM 操作类库，其核心功能是找到 DOM 元素并对其进行操作。&lt;/li&gt;
  &lt;li&gt;拿 jQuery 与 YUI, Dojo 等框架相比是不公平的，就如拿轮胎和汽车相比一样。jQuery 只是一个轮胎，功能很单一，YUI 和 Dojo 等则是相对完整的汽车，除了轮胎，还有引擎、外壳等等。&lt;/li&gt;
  &lt;li&gt;说 jQuery 不适合构建大型应用，就如说轮胎不适合参加赛车比赛一样不合逻辑。你可以用 jQuery 做轮胎，然后选择其他部件组合起来去 DIY 一辆赛车。能否胜出，得看赛车手的 DIY 水准。&lt;/li&gt;
  &lt;li&gt;jQuery的困局在于 DIY 高手不多，经常是一个好轮胎挂上一堆破破烂烂的外壳就上前线了。jQuery 的破局也在于 DIY. DIY 意味着灵活、可替换性，意味着可快速前行和高性能。&lt;/li&gt;
  &lt;li&gt;jQuery 灵活性带来的缺陷，比如有可能由选择器和链式风格导致的低效 DOM 操作，目前在提供了同类功能的 YUI3 等类库中同样存在。这不是类库的问题，更多是因为使用者的经验欠缺导致的。就如一把优秀的菜刀，到了一个拙劣的厨子手中，依旧切不好菜一样。工具很重要，但更重要的是我们得提升自己的刀工。&lt;/li&gt;
  &lt;li&gt;最后，回到第一点：jQuery 是 DOM 操作类库。非 DOM 操作，都是 jQuery 的辅助功能，不是 jQuery 的强项，就如菜刀不能当斧头用一样。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我们可以通过简单封装，让 jQuery 成为 CommonJS 的模块。这样，调用时只要 require 即可：&lt;/p&gt;

&lt;p&gt;test.html:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script src=&quot;http://modules.seajs.com/libs/seajs/1.0.1/sea.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;
seajs.use(&#39;./init&#39;);
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;init.js:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;seajs.config({
  alias: {
    &#39;juery&#39;: &#39;jquery/1.6.1/jquery&#39;
  }
});

define(function(require, exports, module) {
  var $ = require(&#39;jquery&#39;);
  // do something with jQuery
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;jquery&quot;&gt;jQuery插件的模块化&lt;/h2&gt;
&lt;p&gt;jQuery 提供了 DOM 操作功能，在实际应用中，我们还需要 cookie, template, storage 等等一系列功能。这时可以从 jQuery 社区中寻找各种插件来完成。大部分插件通过 jQuery 插件的模块化 一文中提供的方法封装就好。&lt;/p&gt;

&lt;p&gt;之前的封装方法，总结成一句话是：“jQuery 穿肠过，插件身上留”。正如 Kidwind 反馈的一样，每次“穿肠过”的时候都要运行一次插件代码，频繁调用某些插件时，会存在 CPU 浪费，还可能带来隐患：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;假设有以下jquery插件a, b, c, d，它们之间的关系如下&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;b 依赖于 a&lt;/li&gt;
    &lt;li&gt;c 依赖于 a&lt;/li&gt;
    &lt;li&gt;d 依赖于 b c&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;假设页面使用到d插件，那么插件a将进行两次初始化，也就是会调用两次
&lt;code&gt;var $ = require(&#39;jquery&#39;);require(&#39;a&#39;)($);&lt;/code&gt;
进行插件a的注册，当系统复杂时，重复的插件注册会不会影响系统的性能，同时会不会存在隐患？如插件b对引用的插件a进行了部分功能扩展，当引入插件c的时候又重新注册了插件a，那么插件b对插件a的扩展将不存在了，当然改写插件功能的实际情况也许不会存在，此处只是举个例子，说明隐患的存在。
如何避免重复的插件注册，可以避免隐患，同时获得更好的性能（避免了多次插件注册的运算耗时）。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;面对这种情况，我们究竟应该如何做好 jQuery 插件的模块化？&lt;/p&gt;

&lt;p&gt;jQuery 插件的形式&lt;/p&gt;

&lt;p&gt;jQuery 插件一般可以总结为以下模板：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(function($) {  
  // Main plugin function
  $.fn.PLUGIN = function(options) {
    // snip...
  };

  // Public plugin function
  $.fn.PLUGIN.FUNCT = function() {
    // Cool JS action
  };

  // Default settings for the plugin
  $.fn.PLUGIN.defaults = { /* snip... */ };

  // Private function that is used within the plugin
  // snip...
})(jQuery);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;简言之就是往 &lt;code&gt;$.fn&lt;/code&gt; 上添加新成员，有部分插件还会往 &lt;code&gt;$&lt;/code&gt; 上添加成员。&lt;/p&gt;

&lt;p&gt;之前的“穿肠过”模块化方式，可以表示为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;define(function() { return function($) {
  $.fn.PLUGIN = ...
}});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;调用方式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;define(function(require, exports) {
  var $ = require(&#39;jquery&#39;);
  require(&#39;some-jquery-plugin&#39;)($);

  $(sth).PLUGIN(...);
}); 不是很直观，不够方便，还有前面提到的隐患。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;深度模块化&lt;/p&gt;

&lt;p&gt;为了更好的模块化，意味着我们要添加更多代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;define(function(require, exports, module) {
  var $ = require(&#39;jquery&#39;).sub();

  // Main plugin function
  $.fn.PLUGIN = function(options) {
    // snip...
  };

  // Public plugin function
  $.fn.PLUGIN.FUNCT = function() {
    // Cool JS action
  };

  // Default settings for the plugin
  $.fn.PLUGIN.defaults = { /* snip... */ };

  // Private function that is used within the plugin
  // snip...

  module.exports = $;
}); 这样封装后，调用变成：

define(function(require, exports) {
  var $ = require(&#39;jquery&#39;);
  var PLUGIN = require(&#39;some-jquery-plugin&#39;);
  PLUGIN(sth).PLUGIN(...);
}); 这样能解决之前提到的重复初始化问题，但是 `PLUGIN(sth).PLUGIN(…)` 的使用方式怪怪的。比如这个非常帅的 chosen 插件，按照上面的方式模块化后，调用方式为：

chosen(&#39;#some-id&#39;).chosen(); 虽然可用，但怎么看怎么别扭。这是因为 jQuery 是以 DOM 为中心的，代码的默认流程是找到要操作的 DOM 元素，然后对其进行操作。这种代码书写方式，对于模块后的插件来说，很别扭。更好的期待中的调用方式是：

define(function(require, exports) {
  var $ = require(&#39;jquery&#39;);
  var Chosen = require(&#39;chosen&#39;);
 
  var chosen = new Chosen(selector, options);
  chosen.doSth(...);
}); 理论上，我们甚至可以不知道 chosen 依赖 jQuery, 我们需要关心的只是 chosen 的 API. 上面这种理想的调用方式，需要我们对插件进行“深度”模块化：
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;some-jquery-plugin.js:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;define(function(require, exports, module) {
  var $ = require(&#39;jquery&#39;);

  // Main plugin function
  function PLUGIN(selector, options) {
    var els = $(selector);
    // snip...
  };

  // Public plugin function
  PLUGIN.FUNCT = function() {
    // Cool JS action
  };

  // Default settings for the plugin
  PLUGIN.defaults = { /* snip... */ };

  // Private function that is used within the plugin
  // snip...

  module.exports = PLUGIN;
}); 也就是说，在 plugin 的代码里，我们并不对 $.fn 或 $ 进行扩展，只用 $ 来进行 DOM 操作而已，返回的是独立的 PLUGIN 对象，就和我们写普通的业务模块一样。这样，就实现预期中更优雅的调用方式。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;jQuery 的插件机制，在模块化面前很鸡肋。jQuery 一直被冠以“不适合大型项目”，也和 jQuery 的这种插件机制有关系。这会导致大家都去污染 $.fn, 这就和污染全局变量一样。项目一大，冲突的概率，和调试的成本都会变大，很悲剧。&lt;/p&gt;

&lt;p&gt;因此，推荐大家利用模块的机制去重构一部分好用的 jQuery 插件，目前 dew 项目里已经重新实现了 cookie 等部分模块。强烈推荐大家都参与进来，将自己喜欢的，常用的 jQuery 等插件迁移过来。或者推进插件作者直接修改源码，增加对 CommonJS 的支持。路漫漫，但众人拾柴火焰高，星火可燎原，期待大家的参与。&lt;/p&gt;

&lt;p&gt;建议大家直接 fork dew 项目，可以将自己重构的模块 pull request 过来，邮件给 seajs(at)googlegroups.com 群组。讨论和 code review 后，就可以转成 dew 的正式模块。&lt;/p&gt;

&lt;p&gt;等模块丰富起来，我们就可以有更多时间去做更意思的事情了。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>seajs实战参考</title>
   <link href="/seajs/2012/08/14/seajs-combat.html"/>
   <updated>2012-08-14T00:00:00+08:00</updated>
   <id>/seajs/2012/08/14/seajs-combat</id>
   <content type="html">
&lt;h2 id=&quot;seajs&quot;&gt;seajs实战参考&lt;/h2&gt;
&lt;p&gt;该页面列举了 SeaJS 中的常用实战过程中的问题。只要掌握这些方法，就可以娴熟地开始对你的网站进行模块化开发了。&lt;/p&gt;

&lt;p&gt;默认情况下，SeaJS 要求所有文件都是标准的 CMD 模块，但现实场景下，有大量 jQuery 插件等非 CMD 模块存在。在 SeaJS 里，通过以下方式，可以直接调用非标准模块。&lt;/p&gt;

&lt;h3 id=&quot;js&quot;&gt;全站通用的要加载的库只写一次，而不想每个js里都调用，太繁琐&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;//可以放在在 init.js 里暴露到全局，这样，所有在 init.js 之后载入的文件，就都可以直接通过全局变量来拿 $ 等对象。

seajs.use(&#39;init&#39;)

//init.js
define(function(require, exports) {
	var $ = jQuery = require(&#39;jquery&#39;);
	
	// 暴露到全局
  		window.$ = $;
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;jquery&quot;&gt;1. 暴露 jQuery&lt;/h3&gt;
&lt;p&gt;jQuery 插件都依赖 jQuery 模块，为了加载 jQuery 插件，首先得将 jQuery 模块暴露出来：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 配置 jquery 并放入预加载项中
seajs.config({
  alias: {
    &#39;jquery&#39;: &#39;https://a.alipayobjects.com/static/arale/jquery/1.7.2/jquery.js&#39;
  },
  preload: [&quot;jquery&quot;]
})

// 将 jQuery 暴露到全局
seajs.modify(&#39;jquery&#39;, function(require, exports) {
  window.jQuery = window.$ = exports
})
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;jquery-&quot;&gt;2. 修改 jQuery 插件的接口&lt;/h3&gt;
&lt;p&gt;我们以 jquery.cookie 插件为例。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 配置别名
seajs.config({
  alias: {
    &#39;cookie&#39;: &#39;https://raw.github.com/carhartl/jquery-cookie/master/jquery.cookie.js&#39;
  }
})

// 将 jQuery Cookie 插件自动包装成 CMD 接口
seajs.modify(&#39;cookie&#39;, function(require, exports, module) {
  module.exports = $.cookie
})
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;cookie-&quot;&gt;3. 调用 Cookie 插件&lt;/h3&gt;
&lt;p&gt;这样，在其他模块中，就可以直接调用 cookie 插件了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a.js:

define(function(require, exports) {
  var cookie = require(&#39;cookie&#39;)

  cookie(&#39;the_cookie&#39;)
  cookie(&#39;the_cookie&#39;, &#39;the_value&#39;)

  // ...
}) 完整范例：[http://seajs.org/test/issues/auto-transport/test.html](http://seajs.org/test/issues/auto-transport/test.html)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;seajs-1&quot;&gt;seajs里版本号和时间戳问题&lt;/h2&gt;
&lt;p&gt;用 seajs 组织项目，上线后，经常需要更新特定文件或所有文件的时间戳，以清空浏览器缓存。最简单的方式是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//用来维护 jquery 等类库模块的版本号
seajs.config({
  alias: {
    &#39;jquery&#39;: &#39;jquery/1.6.2/jquery&#39;,
    &#39;backbone&#39;: &#39;backbone/0.5.1/backbone&#39;,
    &#39;a&#39;: &#39;a.js?20110801&#39;,
    &#39;b&#39;: &#39;b.js?20110801&#39;
  }
});	

//利用 map,批量更新时间戳是最方便的
seajs.config({
  &#39;map&#39;: [
    [ /^(.*\.(?:css|js))(.*)$/i, &#39;$1?20110801&#39; ]
  ]
});	
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section&quot;&gt;条件加载&lt;/h2&gt;

&lt;p&gt;第一种：把依赖的模块都在 define 头部手工声明，不再依赖 SeaJS 的自动解析功能。这个模块同时依赖 play 和 work 两个模块，加载器会把这两个模块文件都下载下来。如果需要在 require 模块之后串行执行代码，那么只能用这个方式。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;define([&#39;play&#39;, &#39;work&#39;], function(require, exports) {
	 //是出去玩，还是工作？
    var choice = require(condition() ? &#39;play&#39; : &#39;work&#39;);
	//选择的难度
    console.log(choice.hard());
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第二种：使用 require.async 来进行条件加载，从静态分析的角度来看，require.async适合需要执行动态加载的模块很大（比如大量 json 数据），不适合都下载下来。但是require.async 方式加载的模块，不能打包工具找到，自然也不能被打包进上线的 js 中；而前一种方式可以。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;define(function(require, exports) {
    require.async(condition() ? &#39;play&#39; : &#39;work&#39;, function(choice) {
        console.log(choice.hard());
    });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-1&quot;&gt;按需加载&lt;/h2&gt;
&lt;p&gt;很多时候模块并不需要立即加载，等到需要时再加载，性能更好。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//init.js
$(&quot;#J_PicCover&quot;).click(function(){
	require.async(&#39;module/highlight&#39;, function(){
		$(&quot;.buy-info&quot;).highlight({color:&#39;#ffe5c4&#39;,speed:500,complete:function(){
		},iterator:&#39;sinusoidal&#39;});
	});
});

//highlight.js
define(function(require, exports) {
	jQuery.fn.highlight = function(settings) {
		//…...
	}
});
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>seajs快速参考</title>
   <link href="/seajs/2012/08/13/seajs-cheet-sheet.html"/>
   <updated>2012-08-13T00:00:00+08:00</updated>
   <id>/seajs/2012/08/13/seajs-cheet-sheet</id>
   <content type="html">
&lt;h2 id=&quot;seajs&quot;&gt;seajs快速参考&lt;/h2&gt;
&lt;p&gt;该页面列举了 SeaJS 中的常用 API。只要掌握这些方法，就可以娴熟地进行模块化开发。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;启动模块系统&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script src=&quot;http://modules.seajs.org/seajs/1.2.0/sea.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;
  	seajs.use(&#39;./main&#39;);
	seajs.use([&#39;./a&#39;, &#39;./b&#39;], function(a, b) {
	  a.init();
	  b.init();
	});	  
&amp;lt;/script&amp;gt;

//callback 参数是可选的。当只启动加载一个模块，且不需要 callback 时，可以用 data-main 属性来简化：
&amp;lt;script src=&quot;http://modules.seajs.org/seajs/1.2.0/sea.js&quot; data-main=&quot;./main&quot;&amp;gt;&amp;lt;/script&amp;gt;

/*
引入 sea.js 时，可以把 sea.js 与其他文件打包在一起，提前打包好，或利用 combo 服务动态打包。
无论哪一种方式，为了让 sea.js 内部能快速获取到自身路径，推荐手动加上 id 属性：
加上 seajsnode 值，可以让 sea.js 直接获取到自身路径，而不需要通过其他机制去自动获取。
这对性能和稳定性会有一定提升，推荐默认都加上。
*/
&amp;lt;script src=&quot;path/to/sea.js&quot; id=&quot;seajsnode&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;seajsconfig&quot;&gt;seajs.config&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;//seajs.config 可以叠加，可以在多处调用，同名 key 覆盖，不同名的 key 叠加。这样可以做到：区域配置可以覆盖通用配置或可以说在区域配置中可对 seajs config 再做按需配置而不会影响到通用配置。
seajs.config({

  //alias最常用来做版本配置与管理，也可以用来做命名空间管理。
  alias: {
    &#39;es5-safe&#39;: &#39;es5-safe/0.9.2/es5-safe&#39;,
    &#39;json&#39;: &#39;json/1.0.1/json&#39;,
    &#39;jquery&#39;: &#39;jquery/1.7.2/jquery&#39;
  },
  
  /*
  使用 preload 配置项，可以在普通模块加载前，提前加载并初始化好指定模块。
  注意：preload 中的配置，需要等到 use 时才加载。
  preload 配置不能放在模块文件里面
  */
  preload: [
    Function.prototype.bind ? &#39;&#39; : &#39;es5-safe&#39;,
    this.JSON ? &#39;&#39; : &#39;json&#39;
  ],
  
  //值为 true 时，加载器会使用 console.log 输出所有错误和调试信息。 默认为 false, 只输出关键信息
  debug: true,
  
  //该配置可将某个文件映射到另一个。可用于在线调试，非常方便。
  map: [
    [&#39;http://example.com/js/app/&#39;, &#39;http://localhost/js/app/&#39;]
  ],
  
  /*
  SeaJS 在解析顶级标识时，会相对 base 路径来解析。
  注意：一般请不要配置 base 路径，保持默认往往最好最方便。
  base 路径的默认值，与 sea.js 的访问路径相关：
  如果 sea.js 的访问路径是：
    http://example.com/js/libs/sea.js
  则 默认base 路径为：
    http://example.com/js/libs/	 
  */ 
  base: &#39;http://example.com/path/to/base/&#39;,
  
  //获取模块文件时，&amp;lt;script&amp;gt; 或 &amp;lt;link&amp;gt; 标签的 charset 属性。 默认是 utf-8 。
  charset: &#39;utf-8&#39;	  
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;seajsuse&quot;&gt;seajs.use&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;/*
模块加载器
seajs.use 理论上只用于加载启动，不应该出现在 define 中的模块代码里。在模块代码里需要异步加载其他模块时，可以使用 require.async 方法。
*/

seajs.use(&#39;./a&#39;);

seajs.use(&#39;./a&#39;, function(a) {
  a.doSomething();
});

seajs.use([&#39;./a&#39;, &#39;./b&#39;], function(a, b) {
  a.doSomething();
  b.doSomething();
});

//seajs.use 与 dom ready 事件没有任何关系。
//如果某些操作要确保在 dom ready 后执行，需要自己使用 jquery 等类库来保证
seajs.use([&#39;jquery&#39;, &#39;page&#39;], function($, page) {
  $(function() {
    page.init()
  })
})	
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;define&quot;&gt;define&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;/*
CMD 模块定义 define(factory);
define 是全局函数，用来定义模块。
在开发时，define 仅接收一个 factory 参数。
factory 可以是一个函数，也可以是对象、字符串等类型。
factory 为对象、字符串等非函数类型时，表示模块的接口就是该对象、字符串等值。
factory 为函数时，表示模块的构造方法。执行该方法，可以得到模块向外提供的接口。
*/
define(function(require, exports, module) {

  // The module code goes here

});

/*
模块代码需要用 define 回调包起来：id 与 dependencies 参数是可以省略的
id 用来显式指定模块 ID。当你的项目上线，所有的模块都合并到了一个文件中，如果不显示指定， SeaJS 就无从知道哪个模块是哪个了。在开发的时候，一般用不到它。
dependencies 也是如此。它列出了当前模块所依赖的模块，在开发的时候是不需要写明的。 SeaJS 会检查你的模块回调函数，找到所有的 require 语句，从而得到你的模块的所有依赖。 在真正 require 当前模块时，会先去请求这个模块的依赖，加载完毕，再去初始化当前的模块。
*/
define(id, dependencies, function(require, exports, module) {
    // module code.
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;require&quot;&gt;require&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;/*
require 是一个方法，用来获取其他模块提供的接口。
require 接受 模块标识 作为唯一参数

模块依赖解析，靠的是三个重要的规则：
	不能重命名 require
	不能覆盖 require
	require 的参数必须是字符串字面量，不可以 require(foo()) 或者 require(bar)， 也不可以是 require(should_be_a ? &#39;a&#39; : &#39;b&#39;)。	参数值必须是字符串直接量,如 require(&quot;my-module&quot;);
	核心原因是因为在浏览器端，文件的读取是异步的，依赖信息要提前获取，不能在运行时才确定。在服务器端，文件读取是同步的，因此可以是变量。
*/
define(function(require) {
  var a = require(&#39;./a&#39;);
  a.doSomething();
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;requireasync&quot;&gt;require.async&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;/*
require.async(id, callback)
async 方法可用来异步加载模块，并在加载完成后执行指定回调。
*/
define(function(require, exports, module) {
  // load one module
  require.async(&#39;./b&#39;, function(b) {
    b.doSomething();
  });

  // load multiple modules
  require.async([&#39;./c&#39;, &#39;./d&#39;], function(c, d) {
    // do something
  });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;requireresolve&quot;&gt;require.resolve&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;/*
require.resolve(id)
使用模块系统内部的路径解析机制来解析并返回模块路径。该函数不会加载模块，只返回解析后的绝对路径。
*/
define(function(require, exports) {
  console.log(require.resolve(&#39;./b&#39;)); 
  // ==&amp;gt; &#39;http://example.com/js/b.js&#39;
});	
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;exports&quot;&gt;exports&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;/*
exports 是一个对象，用来向外提供模块接口。
exports 仅仅是 module.exports 的一个引用。
在 factory 内部给 exports 重新赋值时，并不会改变 module.exports 的值。
因此给 exports 赋值是无效的，不能用来更改模块接口，正确的写法是用 return 或者给 module.exports 赋值。
exports = {}是错误的，module.exports ={}才是正确的写法。
*/

define(function(require, exports) {
  // snip...
  exports.foo = &#39;bar&#39;;
  exports.doSomething = function() {};
});
module.exports

define(function(require, exports, module) {
  // snip...
  module.exports = {
    name: &#39;a&#39;,
    doSomething: function() {};
  };
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;module&quot;&gt;module&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;/*
module 是一个对象，上面存储了与当前模块相关联的一些属性和方法。
*/
define(function(require, exports, module) {

	//module.id 模块标识。require(module.id) 必然返回此模块的 exports 。
   console.log(require(module.id) === exports); // true
   
   //module.uri根据模块系统的路径解析规则得到的模块绝对路径。
   console.log(module.uri); // http://example.com/path/to/this/file.js
   
   //module.dependencies dependencies 是一个数组，表示当前模块的依赖列表。
   
   /*
   module.exports 当前模块对外提供的接口。
   module.exports 的赋值需要同步执行，不能放在回调函数里
   */
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上接口是最常用的，要牢记于心。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;可写成如下&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;seajs.config({
  alias: {
    &#39;jquery&#39;: &#39;http://modules.seajs.org/jquery/1.7.2/jquery.js&#39;
  }
});

define(&#39;hi&#39;, function(require, exports) {
    exports.sayHi = function() {
        alert(&#39;hi&#39;)
    } 
})

seajs.use([&#39;jquery&#39;, &#39;hi&#39;], function($, h) {
    $(&#39;#beautiful-sea&#39;).click(h.sayHi)
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;js&quot;&gt;模块化后的js写法&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;define(function(require, exports, module) = {
 
    //原jquery.js代码...
 
    module.exports = $.noConflict(true);
});
 
//init.js
define(function(require, exports, module) = {
    var $ = require(&#39;jquery&#39;);
    var m1 = require(&#39;module1&#39;);
     
    exports.initPage = function() {
        $(&#39;.content&#39;).html(m1.run());    
    }
});
 
//module1.js
define(function(require, exports, module) = {
    var $ = require(&#39;jquery&#39;);
    var m2 = require(&#39;module2&#39;);
    var m3 = require(&#39;module3&#39;);
     
    exports.run = function() {
        return $.merge([&#39;module1&#39;], $.merge(m2.run(), m3.run()));    
    }
});
 
//module2.js
define(function(require, exports, module) = {
    exports.run = function() {
        return [&#39;module2&#39;];
    }
});
 
//module3.js
define(function(require, exports, module) = {
    var $ = require(&#39;jquery&#39;);
    var m4 = require(&#39;module4&#39;);
     
    exports.run = function() {
        return $.merge([&#39;module3&#39;], m4.run());    
    }
});
 
//module4.js
define(function(require, exports, module) = {
    exports.run = function() {
        return [&#39;module4&#39;];
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-2&quot;&gt;实际使用中&lt;/h2&gt;
&lt;p&gt;在工程内使用seajs，以前引用的插件、模块也都要用define的语法重新进行封装，比较麻烦，老代码可以不修改，继续使用就好。但强烈建立花点时间都修改成 CMD 模块，这样对以后的维护，以及页面性能很有好处。不然以后修改起来估计会更麻烦。&lt;/p&gt;

&lt;p&gt;其实可以混用的，比如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script src=&quot;jquery.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&quot;underscore.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&quot;backbone.js&quot;&amp;gt;&amp;lt;/script&amp;gt;

&amp;lt;script src=&quot;sea.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样，常用的 jquery 等类库，依旧是传统的用法，用全局变量引用就好，通过同步引入的方式，也不会有依赖顺序问题。
自己的代码，都按照 CMD 规范写成模块的形式。&lt;/p&gt;

&lt;p&gt;其实上面的方式挺好的，特别对于要兼容老代码的情况的。
推荐还是都彻底模块化，看起来要多写一些 require，但值得，因为这样可以让每个模块自身的信息完整，从而减少对
环境的依赖，对后续的可维护性很好益处。&lt;/p&gt;

&lt;h2 id=&quot;seajsapi&quot;&gt;seajs官方api&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://seajs.org/docs/#api&quot;&gt;详细官方文档&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/seajs/seajs/issues/240&quot;&gt;模块系统&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/seajs/seajs/issues/242&quot;&gt;CMD 模块定义规范&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/seajs/seajs/issues/258&quot;&gt;模块标识&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/seajs/seajs/issues/259&quot;&gt;require 书写约定&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/seajs/seajs/issues/260&quot;&gt;模块加载器&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/seajs/seajs/issues/262&quot;&gt;配置&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/seajs/seajs/issues/265&quot;&gt;常用插件&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/seajs/seajs/issues/281&quot;&gt;打包部署&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/seajs/seajs/issues/266&quot;&gt;快速参考&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-3&quot;&gt;第三方库&lt;/h2&gt;
&lt;p&gt;SeaJS 提供了一个类似于npm的管理工具，里面有他们改造好的第三方库，你可以在这里找找是否有适合的:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;spm Git Pero:	&lt;a href=&quot;https://github.com/seajs/spm&quot;&gt;https://github.com/seajs/spm&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;spm module list:	&lt;a href=&quot;http://seajs.cloudfoundry.com/&quot;&gt;http://seajs.cloudfoundry.com/&lt;/a&gt;	&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;seajs-blog-&quot;&gt;seajs blog 等文档&lt;/h2&gt;

&lt;h3 id=&quot;section-4&quot;&gt;初级入门&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/leoo2sk/archive/2011/06/27/write-javascript-with-seajs.html&quot;&gt;使用 SeaJS 实现模块化 JavaScript 开发&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://clonn.blogspot.com/2011/05/seajs-nonblocking-require-library.html&quot;&gt;SeaJS, 模組化開發加載套件&lt;/a&gt; -墙外&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.infoq.com/cn/news/2011/05/nodeparty-hangzhou&quot;&gt;NodeParty 杭州站会议纪实：Jscex, SeaJS 与 MyFOX&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://lifesinger.wordpress.com/2011/05/14/seajs-and-nodejs/&quot;&gt;SeaJS – 跨环境模块化开发实践 - 玉伯&lt;/a&gt; -墙外&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://ghsky.com/2011/05/seajs-first-view.html&quot;&gt;初识 SeaJS&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://lifesinger.wordpress.com/2011/04/26/intro-to-seajs/&quot;&gt;SeaJS – 不仅仅是脚本加载器  - 玉伯&lt;/a&gt; -墙外&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.infoq.com/cn/presentations/hjp-infoq-salon&quot;&gt;去哪儿网的 JavaScript 模块化之路&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://lifesinger.wordpress.com/2011/04/05/seajs-080-released/&quot;&gt;海纳百川、有容乃大 - 玉伯&lt;/a&gt; -墙外&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-5&quot;&gt;中级使用&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://cyj.me/why-seajs/zh/&quot;&gt;seajs所为何-逸才&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://lifesinger.wordpress.com/2011/08/10/extending-built-in-native-objects/&quot;&gt;扩展原生对象与 es5-safe 模块 - 玉伯&lt;/a&gt; -墙外&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://lifesinger.wordpress.com/2011/08/01/best-practice-of-version-management/&quot;&gt;SeaJS 里版本号和时间戳管理的最佳实践&lt;/a&gt; -墙外&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://lifesinger.wordpress.com/2011/07/24/online-local-debug/&quot;&gt;在线本地调试大观 -玉伯&lt;/a&gt; -墙外&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/leoo2sk/archive/2011/07/01/temod-intro.html&quot;&gt;在 SeaJS 中实现 html 模板文件的加载（Temod 介绍）&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.163.com/jinlu_hz/blog/static/113830152201142011225195/&quot;&gt;在 SeaJS 里使用 LABjs&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://lifesinger.wordpress.com/2011/05/26/exports-and-module-load-in-seajs/&quot;&gt;SeaJS 中的 exports 和模块加载 -玉伯&lt;/a&gt;-墙外&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://lifesinger.wordpress.com/2011/05/18/jquery-plugins-modulization/&quot;&gt;jQuery 插件的模块化 -玉伯&lt;/a&gt; -墙外&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://lifesinger.wordpress.com/2011/05/02/seajs-css-support/&quot;&gt;SeaJS – 对 CSS 模块的支持 -玉伯&lt;/a&gt; -墙外&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/seajs/seajs/issues/286&quot;&gt;直接调用 jQuery 插件等非标准模块的方法&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://lifesinger.wordpress.com/2011/08/19/jquery-introduction-and-plugins-modulization/&quot;&gt;jQuery 模块介绍与 jQuery 插件的深度模块化 -玉伯&lt;/a&gt; -墙外&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.heiniuhaha.com/file/sea-zh.js&quot;&gt;seajs中文版源码&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-6&quot;&gt;高级探索&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://hax.iteye.com/blog/1146699&quot;&gt;shim是应该抛异常还是应该fail silently？-hax&lt;/a&gt; -墙外&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://limu.iteye.com/blog/1136712&quot;&gt;扩展 SeaJS 模块定义中的 module 参数的应用示例 -李牧&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://lifesinger.wordpress.com/2011/05/17/the-difference-between-seajs-and-requirejs/&quot;&gt;SeaJS 和 RequireJS 的异同 -玉伯&lt;/a&gt; -墙外&lt;/li&gt;
&lt;/ul&gt;
</content>
 </entry>
 
 <entry>
   <title>使用github+jekyll搭建blog环境，完美替代wordpress</title>
   <link href="/lessons/2012/08/09/use-jekyll-build-blog.html"/>
   <updated>2012-08-09T00:00:00+08:00</updated>
   <id>/lessons/2012/08/09/use-jekyll-build-blog</id>
   <content type="html">
&lt;p&gt;也来讲讲怎么使用github pages做blog环境&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;优点&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;空间免费，github托管，稳定又安全，遭遇过空间商跑路的朋友是不是想起伤心往事；&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;允许本地服务器调试，脱离网络写文章毫无压力，因为可以使用git命令同步来管理文章，版本控制妥妥的，对技术人员来说，一键恢复，实在是神物；&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;还能绑定顶级域名，亲，人家免费空间竟然还允许我们绑域名有木有~~；&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;文章用markedown编写，以前遭受排版困扰的亲们是不是很激动；&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section-1&quot;&gt;购买域名&lt;/h2&gt;
&lt;p&gt;可以去&lt;a href=&quot;http://www.net.cn&quot;&gt;万网&lt;/a&gt;，这两天正好在促销.
&lt;img src=&quot;/assets/themes/twitter/pic/net-cn-sales.png&quot; alt=&quot;net-cn-sales&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;dnspod&quot;&gt;用免费的dnsPod做域名解析&lt;/h2&gt;
&lt;p&gt;dnspod链接地址&lt;a href=&quot;https://www.dnspod.cn/&quot;&gt;https://www.dnspod.cn/&lt;/a&gt;
&lt;img src=&quot;/assets/themes/twitter/pic/dnspod-setting.png&quot; alt=&quot;dnspod settings&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;githubjekyll&quot;&gt;github注册和本地电脑jekyll等环境配置&lt;/h2&gt;
&lt;p&gt;参考最底下的参考文章，省略。。。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;命令&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;h3 id=&quot;git&quot;&gt;git命令获取远程文件&lt;/h3&gt;

    &lt;pre&gt;&lt;code&gt;git clone git@github.com:heiniuhaha/heiniuhaha.github.com.git
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h3 id=&quot;heiniugithubcom&quot;&gt;定位到目录&lt;code&gt;heiniu.github.com&lt;/code&gt;&lt;/h3&gt;

    &lt;pre&gt;&lt;code&gt;cd .ssh/heiniuhaha.github.com
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h3 id=&quot;rake&quot;&gt;使用&lt;code&gt;rake&lt;/code&gt;命令&lt;/h3&gt;

    &lt;pre&gt;&lt;code&gt;rake page           # Create a new page.
rake post           # Begin a new post in ./_posts
rake preview        # Launch preview environment
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h3 id=&quot;markdownhttpsgithubcomothreemarkdown-syntax-zhtwblobmasterbasicsmd&quot;&gt;写文章的时候学习下&lt;a href=&quot;https://github.com/othree/markdown-syntax-zhtw/blob/master/basics.md&quot;&gt;markdown语法&lt;/a&gt;&lt;/h3&gt;
    &lt;p&gt;如:中文单引号 ` 用来标注小块代码,如&lt;code&gt;github&lt;/code&gt; &lt;code&gt;jekyll&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h3 id=&quot;git-1&quot;&gt;最后提交git代码&lt;/h3&gt;
    &lt;pre&gt;&lt;code&gt; git add .
 git commit . -m &#39;just another commit&#39;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-3&quot;&gt;日常发布完整命令&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;git clone git@github.com:heiniuhaha/heiniuhaha.github.com.git//本地如果无远程代码，先做这步，不然就忽略
cd .ssh/heiniuhaha.github.com//定位到你blog的目录下
git pull origin master //先同步远程文件，后面的参数会自动连接你远程的文件
git status //查看本地自己修改了多少文件
git add .//添加远程不存在的git文件
git commit * -m &quot;what I want told to someone&quot;
git push origin master //更新到远程服务器上
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-4&quot;&gt;参考文章&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2012/08/blogging_with_jekyll.html&quot;&gt;搭建一个免费的，无限流量的Blog—-github Pages和Jekyll入门&lt;/a&gt; 阮一峰写于2012-08-25 【推荐】&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://beiyuu.com/github-pages/&quot;&gt;使用Github Pages建独立博客&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://blog.leezhong.com/tech/2010/08/25/make-github-as-blog-engine.html&quot;&gt;使用github作为博客引擎&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://jekyllbootstrap.com/&quot;&gt;The Quickest Way to Blog with Jekyll.&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;git-api-&quot;&gt;附件：git api 总结图&lt;/h2&gt;
&lt;p&gt;链接：&lt;a href=&quot;/assets/themes/twitter/pic/git-api.png&quot;&gt;http://www.heiniuhaha.com/assets/themes/twitter/pic/git-api.png&lt;/a&gt;
&lt;img src=&quot;/assets/themes/twitter/pic/git-api.png&quot; alt=&quot;git api 总结图&quot; /&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Use Google Code Prettify</title>
   <link href="/lessons/2012/08/09/use-google-code-prettify.html"/>
   <updated>2012-08-09T00:00:00+08:00</updated>
   <id>/lessons/2012/08/09/use-google-code-prettify</id>
   <content type="html">
&lt;h2 id=&quot;jekyll-google-code-prettify&quot;&gt;jekyll中代码高亮 google-code-prettify&lt;/h2&gt;
&lt;p&gt;看了jekyll的代码高亮插件pygments,觉得配置太复杂,就用了轻量级的google-code-prettify,使用非常方便.
- 先下载用于高亮代码的文件包,点击&lt;a href=&quot;http://code.google.com/p/google-code-prettify/downloads/list&quot;&gt;google-code-prettify下载地址&lt;/a&gt;下载small版本的代码.
- 复制进相应的目录,找到default.html&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	/Users/heiniu/.ssh/heiniuhaha.github.com/_includes/themes/default.html
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;打开default.html,在最后面添加相应的代码&lt;/p&gt;

  	&lt;script type=&quot;text/javascript&quot; src=&quot;js/code/prettify.js&quot;&gt;&lt;/script&gt;
  	&lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-1.8.0.min.js&quot;&gt;&lt;/script&gt;
  	&lt;script type=&quot;text/javascript&quot;&gt;
&lt;/script&gt;    &lt;pre&gt;&lt;code&gt;    $(function(){
      $(&quot;pre&quot;).addClass(&quot;prettyprint linenums&quot;);
      prettyPrint();
      $(&#39;.entry a&#39;).each(function(){
        if($(this).attr(&quot;href&quot;).indexOf(&quot;heiniuhaha&quot;) == -1){
          $(this).attr(&quot;target&quot;, &quot;_blank&quot;);
        }
      })
    });
  	&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>My Github First Blog</title>
   <link href="/lessons/2012/08/07/my-github-first-blog.html"/>
   <updated>2012-08-07T00:00:00+08:00</updated>
   <id>/lessons/2012/08/07/my-github-first-blog</id>
   <content type="html">
&lt;h2 id=&quot;themes&quot;&gt;应用themes发现的问题&lt;/h2&gt;
&lt;p&gt;我尝试了the-program的theme,但是出现一个使用iframe的警告,看了源文件,没有发现可修复的地方,直接放弃这个theme吧.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/themes/twitter/img/theme-iframe.png&quot; alt=&quot;theme iframe waring&quot; title=&quot;theme iframe waring&quot; /&gt;
####&lt;strong&gt;code:&lt;/strong&gt;
	For security reasons,framing is not allowed.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;iframe src=&quot;http://markdotto.github.com/github-buttons/github-btn.html?user=plusjade&amp;amp;repo=jekyll-bootstrap&amp;amp;type=fork&amp;amp;count=true&quot;&amp;gt;&amp;lt;/iframe&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以我只能换成twitter皮肤,我想这个皮肤应该是最稳定的了.等使用熟练后再改成自己的皮肤.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>svn 文件状态标记含义</title>
   <link href="/svn/2012/08/05/svn-file-status-sense.html"/>
   <updated>2012-08-05T00:00:00+08:00</updated>
   <id>/svn/2012/08/05/svn-file-status-sense</id>
   <content type="html">
&lt;h3 id=&quot;svn-&quot;&gt;svn 文件状态标记含义&lt;/h3&gt;

&lt;p&gt;svn status打印五列字符，紧跟一些空格，接着是文件或者目录名。第一列告诉一个文件的状态或它的内容，返回代码解释如下：&lt;/p&gt;

&lt;h4 id=&quot;a-item&quot;&gt;&lt;code&gt;A item&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;文件、目录或是符号链item预定加入到版本库。&lt;/p&gt;

&lt;h4 id=&quot;c-item&quot;&gt;&lt;code&gt;C item&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;文件item发生冲突，在从服务器更新时与本地版本发生交迭，在你提交到版本库前，必须手工的解决冲突。&lt;/p&gt;

&lt;h4 id=&quot;d-item&quot;&gt;&lt;code&gt;D item&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;文件、目录或是符号链item预定从版本库中删除。&lt;/p&gt;

&lt;h4 id=&quot;m-item&quot;&gt;&lt;code&gt;M item&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;文件item的内容被修改了。&lt;/p&gt;

&lt;h4 id=&quot;r-item&quot;&gt;&lt;code&gt;R item&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;文件、目录或是符号链item预定将要替换版本库中的item，这意味着这个对象首先要被删除，另外一个同名的对象将要被添加，所有的操作发生在一个修订版本。&lt;/p&gt;

&lt;h4 id=&quot;x-item&quot;&gt;&lt;code&gt;X item&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;目录没有版本化，但是与Subversion的外部定义关联，关于外部定义，可以看“外部定义”一节。&lt;/p&gt;

&lt;h4 id=&quot;item&quot;&gt;&lt;code&gt;? item&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;文件、目录或是符号链item不在版本控制之下，你可以通过使用svn status的–quiet（-q）参数或父目录的svn:ignore属性忽略这个问题，关于忽略文件的使用，见“svn:ignore”一节。&lt;/p&gt;

&lt;h4 id=&quot;item-1&quot;&gt;&lt;code&gt;! item&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;文件、目录或是符号链item在版本控制之下，但是已经丢失或者不完整，这可能因为使用非Subversion命令删除造成的，如果是一个目录，有可能是检出或是更新时的中断造成的，使用svn update可以重新从版本库获得文件或者目录，也可以使用svn revert file恢复原来的文件。&lt;/p&gt;

&lt;h4 id=&quot;item-2&quot;&gt;&lt;code&gt;~ item&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;文件、目录或是符号链item在版本库已经存在，但你的工作拷贝中的是另一个。举一个例子，你删除了一个版本库的文件，新建了一个在原来的位置，而且整个过程中没有使用svn delete或是svn add。&lt;/p&gt;

&lt;h4 id=&quot;i-item&quot;&gt;&lt;code&gt;I item&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;文件、目录或是符号链item不在版本控制下，Subversion已经配置好了会在svn add、svn import和svn status命令忽略这个文件，关于忽略文件，见“svn:ignore”一节。注意，这个符号只会在使用svn status的参数–no-ignore时才会出现—否则这个文件会被忽略且不会显示！&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>怎么让一个js文件只有是ie6的时候才加载</title>
   <link href="/ie/2012/08/05/just-ie6-loadjs.html"/>
   <updated>2012-08-05T00:00:00+08:00</updated>
   <id>/ie/2012/08/05/just-ie6-loadjs</id>
   <content type="html">
&lt;p&gt;有朋友问怎么让一个js文件只有是ie6的时候才加载，特记录下:&lt;/p&gt;

&lt;h3 id=&quot;if-ie-6&quot;&gt;方式一：利用&lt;code&gt;[if IE 6]&lt;/code&gt;的判断方式&lt;/h3&gt;

&lt;h4 id=&quot;code&quot;&gt;code&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!--[if IE 6]&amp;gt;
&amp;lt;script src=&quot;http://yourdomain.com/script.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;![endif]--&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;优点：简洁直观&lt;/p&gt;

&lt;p&gt;缺点：阻塞加载&lt;/p&gt;

&lt;h4 id=&quot;if-ie&quot;&gt;&lt;code&gt;[if IE]&lt;/code&gt;的浏览器判断&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;1. &amp;lt;!--[if !IE]&amp;gt;除IE外都可识别 &amp;lt;![endif]--&amp;gt;
2. &amp;lt;!--[if IE]&amp;gt; 所有的IE可识别 &amp;lt;![endif]--&amp;gt;
3. &amp;lt;!--[if IE 5.0]&amp;gt; 只有IE5.0可以识别 &amp;lt;![endif]--&amp;gt; 
4. &amp;lt;!--[if IE 5]&amp;gt; 仅IE5.0与IE5.5可以识别 &amp;lt;![endif]--&amp;gt;
5. &amp;lt;!--[if gt IE 5.0]&amp;gt; IE5.0以及IE5.0以上版本都可以识别 &amp;lt;![endif]--&amp;gt;
6. &amp;lt;!--[if IE 6]&amp;gt; 仅IE6可识别 &amp;lt;![endif]--&amp;gt;
7. &amp;lt;!--[if lt IE 6]&amp;gt; IE6以及IE6以下版本可识别 &amp;lt;![endif]--&amp;gt;
8. &amp;lt;!--[if gte IE 6]&amp;gt; IE6以及IE6以上版本可识别 &amp;lt;![endif]--&amp;gt;
9. &amp;lt;!--[if IE 7]&amp;gt; 仅IE7可识别 &amp;lt;![endif]--&amp;gt;
10. &amp;lt;!--[if lt IE 7]&amp;gt; IE7以及IE7以下版本可识别 &amp;lt;![endif]--&amp;gt;
11. &amp;lt;!--[if gte IE 7]&amp;gt; IE7以及IE7以上版本可识别 &amp;lt;![endif]--&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;按原意是&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code&gt;lt&lt;/code&gt;：less than 当前指定版本以下，不包含当前版本&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code&gt;gt&lt;/code&gt;：greater than 当前指定版本以上，不包含当前版本&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code&gt;lte&lt;/code&gt;：less than or equal 当前指定版本以下，包含当前版本(等于)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code&gt;gte&lt;/code&gt;：greater than or equal 当前指定版本以上，包含当前版本(等于)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;js&quot;&gt;方式二：js判断浏览器版本再异步加载&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;(function() {
	 var isIE6= navigator.appVersion.indexOf(&quot;MSIE 6&quot;)&amp;gt;-1;
	 if(isIE6){
	     var s = document.createElement(&#39;script&#39;);
	     s.type = &#39;text/javascript&#39;;
	     s.async = true;
	     s.src = &#39;http://yourdomain.com/script.js&#39;;
	     var x = document.getElementsByTagName(&#39;script&#39;)[0];
	     x.parentNode.insertBefore(s, x);
	 }
 })();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;优点：适合于有洁癖的开发者，或是希望异步无阻塞加载。&lt;/p&gt;

&lt;p&gt;缺点：代码量多，执行js效率差，如果是需要立即执行渲染的程序，此方式不适合。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;两种方式性能评测&lt;/h3&gt;

&lt;h3 id=&quot;section-1&quot;&gt;参考&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://msdn2.microsoft.com/en-us/library/ms537512.aspx&quot;&gt;MSDN&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://han.guokai.blog.163.com/blog/static/1367182712011115105841181/&quot;&gt;异步加载详解&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
 </entry>
 
 <entry>
   <title>ECMAScript5初探</title>
   <link href="/javascript/2012/08/05/ECMAScript5.html"/>
   <updated>2012-08-05T00:00:00+08:00</updated>
   <id>/javascript/2012/08/05/ECMAScript5</id>
   <content type="html">
&lt;p&gt;Javascript是一个类C的语言，他的面向对象的东西相对于C++/Java比较奇怪，但是其的确相当的强大，在 &lt;a href=&quot;http://www.
cnblogs.com/weidagang2046/&quot;&gt;Todd 同学&lt;/a&gt;的“&lt;a href=&quot;http://coolshell.cn/articles/5202.html&quot;&gt;对象的消息模型&lt;/a&gt;
”一文中我们已经可以看到一些端倪了。这两天有个前同事总在问我Javascript面向对象的东西，所以，索性写篇文章让他看去吧，这里这篇文章主要想从一个整体的
角度来说明一下Javascript的面向对象的编程。（&lt;strong&gt;成文比较仓促，应该有不准确或是有误的地方，请大家批评指正&lt;/strong&gt;）&lt;/p&gt;

&lt;p&gt;另，这篇文章主要基于 &lt;a href=&quot;http://www.ecma-
international.org/publications/standards/Ecma-262.htm&quot;&gt;ECMAScript 5&lt;/a&gt;，
旨在介绍新技术。关于兼容性的东西，请看最后一节。&lt;/p&gt;

&lt;h4 id=&quot;section&quot;&gt;初探&lt;/h4&gt;

&lt;p&gt;我们知道Javascript中的变量定义基本如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var name = &#39;Chen Hao&#39;;;
var email = &#39;haoel(@)hotmail.com&#39;;
var website = &#39;http://coolshell.cn&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果要用对象来写的话，就是下面这个样子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var chenhao = {
    name :&#39;Chen Hao&#39;,
    email : &#39;haoel(@)hotmail.com&#39;,
    website : &#39;http://coolshell.cn&#39;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;于是，我就可以这样访问：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//以成员的方式
chenhao.name;
chenhao.email;
chenhao.website;

//以hash map的方式
chenhao[&quot;name&quot;];
chenhao[&quot;email&quot;];
chenhao[&quot;website&quot;];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关于函数，我们知道Javascript的函数是这样的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var doSomething = function(){
   alert(&#39;Hello World.&#39;);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;于是，我们可以这么干：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var sayHello = function(){
   var hello = &quot;Hello, I&#39;m &quot;+ this.name
                + &quot;, my email is: &quot; + this.email
                + &quot;, my website is: &quot; + this.website;
   alert(hello);
};

//直接赋值，这里很像C/C++的函数指针
chenhao.Hello = sayHello;

chenhao.Hello();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;相信这些东西都比较简单，大家都明白了。 可以看到javascript对象函数是直接声明，直接赋值，直接就用了。runtime的动态语言。&lt;/p&gt;

&lt;p&gt;还有一种比较规范的写法是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//我们可以看到， 其用function来做class。
var Person = function(name, email, website){
    this.name = name;
    this.email = email;
    this.website = website;

    this.sayHello = function(){
        var hello = &quot;Hello, I&#39;m &quot;+ this.name  + &quot;, \n&quot; +
                    &quot;my email is: &quot; + this.email + &quot;, \n&quot; +
                    &quot;my website is: &quot; + this.website;
        alert(hello);
    };
};

var chenhao = new Person(&quot;Chen Hao&quot;, &quot;haoel@hotmail.com&quot;,
                                     &quot;http://coolshell.cn&quot;);
chenhao.sayHello(); 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;顺便说一下，要删除对象的属性，很简单：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;delete chenhao[&#39;email&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的这些例子，我们可以看到这样几点：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Javascript的数据和成员封装很简单。没有类完全是对象操作。纯动态！&lt;/li&gt;
  &lt;li&gt;Javascript function中的this指针很关键，如果没有的话，那就是局部变量或局部函数。&lt;/li&gt;
  &lt;li&gt;Javascript对象成员函数可以在使用时临时声明，并把一个全局函数直接赋过去就好了。&lt;/li&gt;
  &lt;li&gt;Javascript的成员函数可以在实例上进行修改，也就是说不同实例相同函数名的行为不一定一样。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;objectdefineproperty&quot;&gt;属性配置 - Object.defineProperty&lt;/h4&gt;

&lt;p&gt;先看下面的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//创建对象
var chenhao = Object.create(null);

//设置一个属性
 Object.defineProperty( chenhao,
                &#39;name&#39;, { value:  &#39;Chen Hao&#39;,
                          writable:     true,
                          configurable: true,
                          enumerable:   true });

//设置多个属性
Object.defineProperties( chenhao,
    {
        &#39;email&#39;  : { value:  &#39;haoel@hotmail.com&#39;,
                     writable:     true,
                     configurable: true,
                     enumerable:   true },
        &#39;website&#39;: { value: &#39;http://coolshell.cn&#39;,
                     writable:     true,
                     configurable: true,
                     enumerable:   true }
    }
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面就说说这些属性配置是什么意思。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;writable：这个属性的值是否可以改。&lt;/li&gt;
  &lt;li&gt;configurable：这个属性的配置是否可以改。&lt;/li&gt;
  &lt;li&gt;enumerable：这个属性是否能在for…in循环中遍历出来或在Object.keys中列举出来。&lt;/li&gt;
  &lt;li&gt;value：属性值。&lt;/li&gt;
  &lt;li&gt;get()/set(_value)：get和set访问器。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;getset-&quot;&gt;Get/Set 访问器&lt;/h4&gt;

&lt;p&gt;关于get/set访问器，它的意思就是用get/set来取代value（其不能和value一起使用），示例如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var  age = 0;
Object.defineProperty( chenhao,
            &#39;age&#39;, {
                      get: function() {return age+1;},
                      set: function(value) {age = value;}
                      enumerable : true,
                      configurable : true
                    }
);
chenhao.age = 100; //调用set
alert(chenhao.age); //调用get 输出101（get中+1了）;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们再看一个更为实用的例子——利用已有的属性(age)通过get和set构造新的属性(birth_year)：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Object.defineProperty( chenhao,
            &#39;birth_year&#39;,
            {
                get: function() {
                    var d = new Date();
                    var y = d.getFullYear();
                    return ( y - this.age );
                },
                set: function(year) {
                    var d = new Date();
                    var y = d.getFullYear();
                    this.age = y - year;
                }
            }
);

alert(chenhao.birth_year);
chenhao.birth_year = 2000;
alert(chenhao.age);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样做好像有点麻烦，你说，我为什么不写成下面这个样子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var chenhao = {
    name: &quot;Chen Hao&quot;,
    email: &quot;haoel@hotmail.com&quot;,
    website: &quot;http://coolshell.cn&quot;,
    age: 100,
    get birth_year() {
        var d = new Date();
        var y = d.getFullYear();
        return ( y - this.age );
    },
    set birth_year(year) {
        var d = new Date();
        var y = d.getFullYear();
        this.age = y - year;
    }

};
alert(chenhao.birth_year);
chenhao.birth_year = 2000;
alert(chenhao.age);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;是的，你的确可以这样的，不过通过defineProperty()你可以干这些事：&lt;/p&gt;

&lt;p&gt;1）设置如 writable，configurable，enumerable 等这类的属性配置。&lt;/p&gt;

&lt;p&gt;2）动态地为一个对象加属性。比如：一些HTML的DOM对像。&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;查看对象属性配置&lt;/h4&gt;

&lt;p&gt;如果查看并管理对象的这些配置，下面有个程序可以输出对象的属性和配置等东西：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//列出对象的属性.
function listProperties(obj)
{
    var newLine = &quot;  
&quot;;
    var names = Object.getOwnPropertyNames(obj);
    for (var i = 0; i &amp;lt; names.length; i++) {
        var prop = names[i];
        document.write(prop + newLine);

        // 列出对象的属性配置（descriptor）动用getOwnPropertyDescriptor函数。
        var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
        for (var attr in descriptor) {
            document.write(&quot;...&quot; + attr + &#39;: &#39; + descriptor[attr]);
            document.write(newLine);
        }
        document.write(newLine);
    }
}

listProperties(chenhao);
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;callapply-bind--this&quot;&gt;call，apply， bind 和 this&lt;/h4&gt;

&lt;p&gt;关于Javascript的this指针，和C++/Java很类似。 我们来看个示例：（这个示例很简单了，我就不多说了）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function print(text){
    document.write(this.value + &#39; - &#39; + text+ &#39;  
&#39;);
}

var a = {value: 10, print : print};
var b = {value: 20, print : print};

print(&#39;hello&#39;);// this =&amp;gt; global, output &quot;undefined - hello&quot;

a.print(&#39;a&#39;);// this =&amp;gt; a, output &quot;10 - a&quot;
b.print(&#39;b&#39;); // this =&amp;gt; b, output &quot;20 - b&quot;

a[&#39;print&#39;](&#39;a&#39;); // this =&amp;gt; a, output &quot;10 - a&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们再来看看call 和 apply，这两个函数的差别就是参数的样子不一样，另一个就是性能不一样，apply的性能要差很多。（关于性能，可到
&lt;a href=&quot;http://jsperf.com/&quot;&gt;JSPerf&lt;/a&gt; 上去跑跑看看）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;print.call(a, &#39;a&#39;); // this =&amp;gt; a, output &quot;10 - a&quot;
print.call(b, &#39;b&#39;); // this =&amp;gt; b, output &quot;20 - b&quot;

print.apply(a, [&#39;a&#39;]); // this =&amp;gt; a, output &quot;10 - a&quot;
print.apply(b, [&#39;b&#39;]); // this =&amp;gt; b, output &quot;20 - b&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是在bind后，this指针，可能会有不一样，但是因为Javascript是动态的。如下面的示例&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var p = print.bind(a);
p(&#39;a&#39;);             // this =&amp;gt; a, output &quot;10 - a&quot;
p.call(b, &#39;b&#39;);     // this =&amp;gt; a, output &quot;10 - b&quot;
p.apply(b, [&#39;b&#39;]);  // this =&amp;gt; a, output &quot;10 - b&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-2&quot;&gt;继承 和 重载&lt;/h4&gt;

&lt;p&gt;通过上面的那些示例，我们可以通过Object.create()来实际继承，请看下面的代码，Student继承于Object。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var Person = Object.create(null);

Object.defineProperties
(
    Person,
    {
        &#39;name&#39;  : {  value: &#39;Chen Hao&#39;},
        &#39;email&#39;  : { value : &#39;haoel@hotmail.com&#39;},
        &#39;website&#39;: { value: &#39;http://coolshell.cn&#39;}
    }
);

Person.sayHello = function () {
    var hello = &quot;

Hello, I am &quot;+ this.name  + &quot;,   
&quot; +
                &quot;my email is: &quot; + this.email + &quot;,   
&quot; +
                &quot;my website is: &quot; + this.website;
    document.write(hello + &quot;  
&quot;);
}

var Student = Object.create(Person);
Student.no = &quot;1234567&quot;; //学号
Student.dept = &quot;Computer Science&quot;; //系

//使用Person的属性
document.write(Student.name + &#39; &#39; + Student.email + &#39; &#39; + Student.website +&#39;  
&#39;);

//使用Person的方法
Student.sayHello();

//重载SayHello方法
Student.sayHello = function (person) {
    var hello = &quot;

Hello, I am &quot;+ this.name  + &quot;,   
&quot; +
                &quot;my email is: &quot; + this.email + &quot;,   
&quot; +
                &quot;my website is: &quot; + this.website + &quot;,   
&quot; +
                &quot;my student no is: &quot; + this. no + &quot;,   
&quot; +
                &quot;my departent is: &quot; + this. dept;
    document.write(hello + &#39;  
&#39;);
}
//再次调用
Student.sayHello();

//查看Student的属性（只有 no 、 dept 和 重载了的sayHello）
document.write(&#39;

&#39; + Object.keys(Student) + &#39;  
&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通用上面这个示例，我们可以看到，Person里的属性并没有被真正复制到了Student中来，但是我们可以去存取。这是因为Javascript用委托实现了这一
机制。其实，这就是Prototype，Person是Student的Prototype。&lt;/p&gt;

&lt;p&gt;当我们的代码需要一个属性的时候，Javascript的引擎会先看当前的这个对象中是否有这个属性，如果没有的话，就会查找他的Prototype对象是否有这个属
性，一直继续下去，直到找到或是直到没有Prototype对象。&lt;/p&gt;

&lt;p&gt;为了证明这个事，我们可以使用Object.getPrototypeOf()来检验一下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Student.name = &#39;aaa&#39;;

//输出 aaa
document.write(&#39;

&#39; + Student.name + &#39;

&#39;);

//输出 Chen Hao
document.write(&#39;

&#39; +Object.getPrototypeOf(Student).name + &#39;

&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;于是，你还可以在子对象的函数里调用父对象的函数，就好像C++里的 Base::func()
一样。于是，我们重载hello的方法就可以使用父类的代码了，如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//新版的重载SayHello方法
Student.sayHello = function (person) {
    Object.getPrototypeOf(this).sayHello.call(this);
    var hello = &quot;my student no is: &quot; + this. no + &quot;,   
&quot; +
                &quot;my departent is: &quot; + this. dept;
    document.write(hello + &#39;  
&#39;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个很强大吧。&lt;/p&gt;

&lt;h4 id=&quot;section-3&quot;&gt;组合&lt;/h4&gt;

&lt;p&gt;上面的那个东西还不能满足我们的要求，我们可能希望这些对象能真正的组合起来。为什么要组合？因为我们都知道是这是OO设计的最重要的东西。不过，这对于Javasc
ript来并没有支持得特别好，不好我们依然可以搞定个事。&lt;/p&gt;

&lt;p&gt;首先，我们需要定义一个Composition的函数：（target是作用于是对象，source是源对象），下面这个代码还是很简单的，就是把source里的属
性一个一个拿出来然后定义到target中。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Composition(target, source)
{
    var desc  = Object.getOwnPropertyDescriptor;
    var prop  = Object.getOwnPropertyNames;
    var def_prop = Object.defineProperty;

    prop(source).forEach(
        function(key) {
            def_prop(target, key, desc(source, key))
        }
    )
    return target;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有了这个函数以后，我们就可以这来玩了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//艺术家
var Artist = Object.create(null);
Artist.sing = function() {
    return this.name + &#39; starts singing...&#39;;
}
Artist.paint = function() {
    return this.name + &#39; starts painting...&#39;;
}

//运动员
var Sporter = Object.create(null);
Sporter.run = function() {
    return this.name + &#39; starts running...&#39;;
}
Sporter.swim = function() {
    return this.name + &#39; starts swimming...&#39;;
}

Composition(Person, Artist);
document.write(Person.sing() + &#39;  
&#39;);
document.write(Person.paint() + &#39;  
&#39;);

Composition(Person, Sporter);
document.write(Person.run() + &#39;  
&#39;);
document.write(Person.swim() + &#39;  
&#39;);

//看看 Person中有什么？（输出：sayHello,sing,paint,swim,run）
document.write(&#39;

&#39; + Object.keys(Person) + &#39;  
&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;prototype--&quot;&gt;Prototype 和 继承&lt;/h4&gt;

&lt;p&gt;我们先来说说Prototype。我们先看下面的例程，这个例程不需要解释吧，很像C语言里的函数指针，在C语言里这样的东西见得多了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var plus = function(x,y){
    document.write( x + &#39; + &#39; + y + &#39; = &#39; + (x+y) + &#39;  
&#39;);
    return x + y;
};

var minus = function(x,y){
    document.write(x + &#39; - &#39; + y + &#39; = &#39; + (x-y) + &#39;  
&#39;);
    return x - y;
};

var operations = {
    &#39;+&#39;: plus,
    &#39;-&#39;: minus
};

var calculate = function(x, y, operation){
    return operations[operation](x, y);
};

calculate(12, 4, &#39;+&#39;);
calculate(24, 3, &#39;-&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么，我们能不能把这些东西封装起来呢，我们需要使用prototype。看下面的示例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var Cal = function(x, y){
    this.x = x;
    this.y = y;
}

Cal.prototype.operations = {
    &#39;+&#39;: function(x, y) { return x+y;},
    &#39;-&#39;: function(x, y) { return x-y;}
};

Cal.prototype.calculate = function(operation){
    return this.operations[operation](this.x, this.y);
};

var c = new Cal(4, 5);

c.calculate(&#39;+&#39;);
c.calculate(&#39;-&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这就是prototype的用法，prototype 是javascript这个语言中最重要的内容。网上有太多的文章介始这个东西了。说白了，prototype
就是对一对象进行扩展，其特点在于通过“复制”一个已经存在的实例来返回新的实例,而不是新建实例。被复制的实例就是我们所称的“原型”，这个原型是可定制的（当然，
这里没有真正的复制，实际只是委托）。上面的这个例子中，我们扩展了实例Cal，让其有了一个operations的属性和一个calculate的方法。&lt;/p&gt;

&lt;p&gt;这样，我们可以通过这一特性来实现继承。还记得我们最最前面的那个Person吧， 下面的示例是创建一个Student来继承Person。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Person(name, email, website){
    this.name = name;
    this.email = email;
    this.website = website;
};

Person.prototype.sayHello = function(){
    var hello = &quot;Hello, I am &quot;+ this.name  + &quot;,   
&quot; +
                &quot;my email is: &quot; + this.email + &quot;,   
&quot; +
                &quot;my website is: &quot; + this.website;
    return hello;
};

function Student(name, email, website, no, dept){
    var proto = Object.getPrototypeOf;
    proto(Student.prototype).constructor.call(this, name, email, website);
    this.no = no;
    this.dept = dept;
}

// 继承prototype
Student.prototype = Object.create(Person.prototype);

//重置构造函数
Student.prototype.constructor = Student;

//重载sayHello()
Student.prototype.sayHello = function(){
    var proto = Object.getPrototypeOf;
    var hello = proto(Student.prototype).sayHello.call(this) + &#39;  
&#39;;
    hello += &quot;my student no is: &quot; + this. no + &quot;,   
&quot; +
             &quot;my departent is: &quot; + this. dept;
    return hello;
};

var me = new Student(
    &quot;Chen Hao&quot;,
    &quot;haoel@hotmail.com&quot;,
    &quot;http://coolshell.cn&quot;,
    &quot;12345678&quot;,
    &quot;Computer Science&quot;
);
document.write(me.sayHello());
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-4&quot;&gt;兼容性&lt;/h4&gt;

&lt;p&gt;上面的这些代码并不一定能在所有的浏览器下都能运行，因为上面这些代码遵循 ECMAScript 5 的规范，关于ECMAScript 5
的浏览器兼容列表，你可以看这里“&lt;a href=&quot;http://kangax.github.com/es5-compat-table/&quot;&gt;ES5浏览器兼容表&lt;/a&gt;”。&lt;/p&gt;

&lt;p&gt;本文中的所有代码都在Chrome最新版中测试过了。&lt;/p&gt;

&lt;p&gt;下面是一些函数，可以用在不兼容ES5的浏览器中：&lt;/p&gt;

&lt;h5 id=&quot;objectcreate&quot;&gt;Object.create()函数&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;function clone(proto) {
    function Dummy() { }

    Dummy.prototype             = proto;
    Dummy.prototype.constructor = Dummy;

    return new Dummy(); //等价于Object.create(Person);
}

var me = clone(Person);
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&quot;defineproperty&quot;&gt;defineProperty()函数&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;function defineProperty(target, key, descriptor) {
    if (descriptor.value){
        target[key] = descriptor.value;
    }else {
        descriptor.get &amp;amp;&amp;amp; target.__defineGetter__(key, descriptor.get);
        descriptor.set &amp;amp;&amp;amp; target.__defineSetter__(key, descriptor.set);
    }

    return target
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&quot;keys&quot;&gt;keys()函数&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;function keys(object) { var result, key
    result = [];
    for (key in object){
        if (object.hasOwnProperty(key))  result.push(key)
    }

    return result;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&quot;objectgetprototypeof-&quot;&gt;Object.getPrototypeOf() 函数&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;function proto(object) {
    return !object?                null
         : &#39;__proto__&#39; in object?  object.__proto__
         : /* not exposed? */      object.constructor.prototype
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&quot;bind-&quot;&gt;bind 函数&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;var slice = [].slice

function bind(fn, bound_this) { var bound_args
    bound_args = slice.call(arguments, 2)
    return function() { var args
        args = bound_args.concat(slice.call(arguments))
        return fn.apply(bound_this, args) }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-5&quot;&gt;参考&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;W3CSchool&lt;/li&gt;
  &lt;li&gt;MDN (Mozilla Developer Network)&lt;/li&gt;
  &lt;li&gt;MSDN (Microsoft Software Development Network)&lt;/li&gt;
  &lt;li&gt;Understanding Javascript OOP&lt;a href=&quot;http://killdream.github.com/blog/2011/10/understanding-javascript-oop/&quot;&gt;http://killdream.github.com/blog/2011/10/understanding-javascript-oop/&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;基于ECMAScript5的继承链实现&lt;a href=&quot;http://www.oschina.net/code/snippet_58016_4157&quot;&gt;http://www.oschina.net/code/snippet_58016_4157&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>jQuery1.4.3核心源码解读</title>
   <link href="/jquery/2012/07/30/jquery-1.4.3-core-source.html"/>
   <updated>2012-07-30T00:00:00+08:00</updated>
   <id>/jquery/2012/07/30/jquery-1.4.3-core-source</id>
   <content type="html">
&lt;h3 id=&quot;jquery&quot;&gt;构造jquery.&lt;/h3&gt;

&lt;p&gt;相对于其它库里传统的构造对象方法. jquery提供了一种截然不同的方法. 它选择创造一个全新的奇异世界. &lt;/p&gt;

&lt;p&gt;首先所有的jquery代码被一个自动执行的闭包包裹起来, 只在后面暴露$和jQuery这2个变量给外界 尽量避开变量冲突. &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(function(window,  undefined){  
…..  
})(window)  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;window和undefined都是为了减少变量查找所经过的scope. 当window通过传递给闭包内部之后, 在闭包内部使用它的时候, 
可以把它当成一个局部变量, 显然比原先在window scope下查找的时候要快一些. 
undefined也是同样的道理, 其实这个undefined并不是javascript数据类型六君子之一的undefined, 而是一个普普通通的变量名. 
只是因为没给它传递值. 它的值就是undefined.  undefined并不是javascript的保留字. &lt;/p&gt;

&lt;p&gt;然后是一个套子套住jquery的构造方法 &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var jQuery = (function(){   --------------------jq1  
    var jQuery = function( selector, context ){    ---------------jq2  
        ……..  
};  
    return (window.jQuery = window.$ = jQuery);  
})()  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先定义jq1, 这个jQuery最终在&lt;code&gt;return  (window.jQuery = window.$ = jQuery)&lt;/code&gt;的时候会变成 
window下面的变量供外界使用. 
而jq2供jquery内部执行的时候调用. 最终作为jq1的引用返回. 
&lt;code&gt;return (window.jQuery = window.$ = jQuery);&lt;/code&gt;这句话等价于 &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;window.jQuery = window.$ = jQuery;  
return window. jQuery.  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在来看看jquery对象是怎么被创建出来的. jquery作为一个独立特行的库,  它产生jquery对象时并不需要用new 操作符.. 
它宁愿选择这种方式, 比如要产生一个构造函数Man的对象. &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Man(name){  
    this.name = name;     
}  
  
function People(name){  
    return new Man(name);  
}  
  
var pe = People(&quot;zengtan&quot;);  
alert (pe.name);  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同样真正作为jQuery对象的构造方法的并不是 
	function (selector, context){ 
	} 
而是&lt;code&gt;jQuery.fn.init. &lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var jQuery  =  function( selector, context ) {            
        return new jQuery.fn.init( selector, context );  
    }  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;jQuery.fn就是jQuery.prototype. 见源码102行. 
&lt;code&gt;jQuery.fn = jQuery.prototype = {} &lt;/code&gt;&lt;/p&gt;

&lt;p&gt;init是挂在jQuery.prototype上的属性. 
当&lt;code&gt;jQuery(‘div’)&lt;/code&gt;的时候, 实际上转交给了&lt;code&gt;jQuery.fn.init&lt;/code&gt;构造函数来生成对象. 
当然我们想用new jQuery来生成jquery对象也可以. 跟直接用jQuery()没区别. 
因为构造函数一定会返回一个对象.如果显示指定了返回某个对象.就会返回那个对象, 
否则才会返回this对象. 
好比说, 有只母鸡被你强迫下一个蛋, 它会先看窝里有没有别人的蛋, 如果没有,才会自己努力下一个. 
这里显然返回的是jQuery.fn.init的对象. &lt;/p&gt;

&lt;p&gt;也许现在你开始回忆制作jquery插件时, 明明是给jQuery.prototype添加方法. 
这里返回的又是jQuery.prototype.init的对象. 
原来在源码333行,  jQuery.prototype.init.prototype = jQuery. prototype; 
现在很容易看明白. 给jQuery.prototype添加方法就等于给jQuery. prototype.init.prototype添加方法了. 
JQuery api里的方法大部分都是通过jQuery.prototype扩展上去的, 除此之外. 我们还要给jquery对象加上索引. 给集合添加length属性,让他们更像一个数组里的元素. &lt;/p&gt;

&lt;p&gt;搞明白这些, 再来看jQuery. prototype.init这个方法里究竟是怎样生产jquery对象的. 
我们可以把jQuery. prototype.init想象成一个火腿肠加工器. 只要你放了正确的原料进去, 
它就可以把原料变成火腿肠生产出来.如果你不小心放错了原料.它也会帮你变成火腿肠. 不过只有塑料包装, 里面没有火腿. 
当然这个加工器里面的构造是很复杂的, 它需要判断材料种类, 数量等等. 
一般这个材料主要为这4种情况 
1 dom节点 
2 字符串 
3 函数 
4 数组 
5 其他元素 &lt;/p&gt;

&lt;p&gt;一 jQuery构造方法 
jQuery的构造方法会生成一组jquery对象的集合.具体关于init方法的分析, 还是留在选择器部分说吧. &lt;/p&gt;

&lt;h3 id=&quot;jquery-1&quot;&gt;jQuery对象访问&lt;/h3&gt;

&lt;p&gt;jquery构造完对象之后, 会提供一些方法访问这些对象. &lt;/p&gt;

&lt;p&gt;1  jQuery.prototype.size&lt;br /&gt;
集合内元素的数量 
就是通过this.length得到. &lt;/p&gt;

&lt;p&gt;2  jQuery.prototype.get&lt;br /&gt;
按照索引取得集合内某个元素, 返回包装前的原始对象 &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;get: function( num ) {  
        return num == null ?   
 //如果参数为null或者undefiend. 注意是==.  
            this.toArray() :  //如果不传参数, 集合内的元素全部转化为一个数组(1)  
            ( num &amp;lt; 0 ? this.slice(num)[ 0 ] : this[ num ] );   
//调用silce方法截取某一个.可以传入负数并且返回的是包装前的对象.  
    }  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(1) 看看这里的this.toArray函数. &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;toArray: function() {  
        return slice.call( this, 0 );  
    }  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;很简单, 就是让当前jquery对象冒充Array的对象, 调用Array.prototype.slice进行截断. 返回的是一个数组. 
至于为什么可以像这样使用对象冒充. 我们抽个地方来好好讨论一下. 
其实如果查看v8之类开源引擎的源码就知道(当然也可以在ecma里挣扎一番). 要调用Array原型链上的方法. 通常这个对象满足2个条件就可以了. 
1, 本身可以存取属性. 
2, length属性不能是只读(可以没有length属性). 
由于Array.prototype.slice方法太长了. 我拿Array.prototype.push方法举例. 在V8的src目录下的array.js可以找到这些方法. 
比如push &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function ArrayPush() {  
  var n = ToUint32(this.length);  
 /* 
    对象/数组本身的length. 如果为null或者undefined, 会在ToUint32中转化为0. 所以 
    即使没有length属性,也会给一个默认的0值. 
 */  
  var m = %_ArgumentsLength();    //参数的length.  
  for (var i = 0; i &amp;lt; m; i++) {  
    this[i+n] = %_Arguments(i);   //复制属性  
  }  
  this.length = n + m;            //重设length.  
  return this.length;  
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到push操作的核心就是复制属性和重设长度. 
jquery对象完全可以满足这2个条件. 同样的道理 一个对象字面量{}也可以. 
而string类型的不可以, 因为不能在string上存取属性. function对象虽然可以存取属性, 也有length属性. 
不过它的length属性比较特殊, 表示形参的个数, 是一个只读属性, 源码中的this.length = n + m这一句不起作用, 所以function对象也不行. 同理window对象也不行. 
上面的slice.call也是这个原理, 虽然slice方法的实现更复杂一点. &lt;/p&gt;

&lt;p&gt;明白了这个,我们可以解释很多奇怪的问题.比如: &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var a = {};  
a[0] = 1;  
a[1] = 2;  
Array.prototype.push(a, 3);  
alert (a.length)   // a没有length属性, 默认的给0值, 所以结果为1 .  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果在push操作之前添加一句 a.length = 2; 
再进行push操作后, a.length就为3了. &lt;/p&gt;

&lt;p&gt;3 jQuery.prototype.index&lt;br /&gt;
搜索匹配的元素，并返回相应元素的索引值，从0开始计数。 
如果不给 .index() 方法传递参数，那么返回值就是这个jQuery对象集合中第一个元素相对于其同辈元素的位置。 
如果参数是一组DOM元素或者jQuery对象，那么返回值就是传递的元素相对于原先集合的位置。 
如果参数是一个选择器，那么返回值就是原先元素相对于选择器匹配元素中的位置。如果找不到匹配的元素，则返回-1。 
没有什么特别需要解释的, 直接看代码. &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;index: function( elem ) {  
        if ( !elem || typeof elem === &quot;string&quot; ) {     
        //如果没有参数, 或者参数是选择器.  
            return jQuery.inArray( this[0],  
                elem ? jQuery( elem ) : this.parent().children() );  
        //如果有参数(选择器), 则查找元素本身在这些选择器组成的jq对象集合中的位置  
        //如果没有参数, 查找元素本身在它的兄弟节点之间的位置. this.parent().children()可以取得自己和全部兄弟节点.  
}  
        return jQuery.inArray(  
            //参数是一个对象  
            elem.jquery ? elem[0] : elem, this );  
            //如果是jquery对象, 取得它的原始节点. 再查找在当前集合中的位置     
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;顾名思义jQuery.inArray就是判断数组里有没有某个元素.当然这里的数组也包括伪数组. 
这个方法虽然实现起来很简单, 关于inArray这个名字在jquery的官方论坛却有颇多争议. 
很多人认为它应该返回true或者false, 而不是索引的位置. 
john resig只是说暂时还不准备修改这个方法. &lt;/p&gt;

&lt;p&gt;有些浏览器还不支持Array.prototype.indexOf方法. 所以首先在源码的851行, 有这样一段代码. &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if ( Array.prototype.indexOf ) {  
    jQuery.inArray = function( elem, array ) {  
        return indexOf.call( array, elem );  
    };  
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果支持Array.prototype.indexOf. 则重写jQuery.inArray, 直接用Array.prototype.indexOf.call(array, elem ); 
在页面加载的时候就重写这个方法. 也避免了在函数里反复判断造成的浪费. 
然后 &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;inArray: function( elem, array ) {  
        if ( array.indexOf ) {  
//确认indexOf方法存在.或防止indexOf方法被改写.  
            return array.indexOf( elem );  
        }  
        for ( var i = 0, length = array.length; i &amp;lt; length; i++ ) {  
            //否则遍历数组, 返回正确的索引.  
if ( array[ i ] === elem ) {  
                return i;  
            }  
        }  
        return -1;  //如果数组里没有这个元素, 返回-1.  
    }  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section&quot;&gt;数据缓存&lt;/h3&gt;

&lt;p&gt;jQuery.data &lt;/p&gt;

&lt;p&gt;在实际应用中, 我们经常需要往节点中缓存一些数据. 这些数据往往和dom元素紧密相关. dom节点也是对象, 所以我们可以直接扩展dom节点的属性. 
不过肆意污染dom节点是不良少年的行为. 我们需要一种低耦合的方式让dom和缓存数据能够联系起来. &lt;/p&gt;

&lt;p&gt;jquery提供了一套非常巧妙的缓存办法. &lt;/p&gt;

&lt;p&gt;我们先在jquery内部创建一个cache对象{}, 来保存缓存数据. &lt;/p&gt;

&lt;p&gt;然后往需要进行缓存的dom节点上扩展一个值为&lt;code&gt;jQuery.expando&lt;/code&gt;的属性, 这里是&lt;code&gt;&quot;jquery&quot; + (new Date).getTime(). &lt;/code&gt;&lt;/p&gt;

&lt;p&gt;接着把每个节点的&lt;code&gt;dom[jQuery.expando]&lt;/code&gt;的值都设为一个自增的变量id,保持全局唯一性. 
这个id的值就作为cache的key用来关联dom节点和数据. 
也就是说cache[id]就取到了这个节点上的所有缓存. &lt;/p&gt;

&lt;p&gt;而每个元素的所有缓存都被放到了一个map里面,这样可以同时缓存多个数据. &lt;/p&gt;

&lt;p&gt;比如有2个节点dom1和dom2, 它们的缓存数据在cache中的格式应该是这样 &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cache = {  
    dom1[  jQuery.expando ]: {  
        key1: value1,  
        key2: value2  
	},  
	dom2[ jQuery.expando ] {  
	    key3: value3,  
	    key4: value4  
	}  
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;jQuery.expando&lt;/code&gt;的值等于 &lt;code&gt;&quot;jquery&quot;+当前时间&lt;/code&gt;, 元素本身具有这种属性而起冲突的情况是微乎其微的. &lt;/p&gt;

&lt;p&gt;我们在看源码之前, 先根据上面的原理来自己实现一个简单的缓存系统.以便增强理解. &lt;/p&gt;

&lt;p&gt;先把跟data相关的所有代码都封装到一个闭包里,通过返回的接口暴露给外界. 
同时为了简便,我们拆分成setData和getData两个方法. &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div id=&quot;ddd&quot;&amp;gt;dddddddd&amp;lt;/div&amp;gt;  
  
&amp;lt;script&amp;gt;  
  
var Data = function(){  
    var cache = {};  
    var expando = &quot;zengtan&quot; + +new Date;  
    var uuid = 1;  
      
    var setData = function(elem, key, value){  
            var id = elem[expando];  
            if (!id){   //第一次给元素设置缓存  
                id = ++uuid;  
                elem[expando] = id;  
            }  
            if (!cache[id]){   //这个元素第一次进行缓存或者缓存已被清空  
                cache[id] = {};  
            }  
            cache[id][key] = value;  
    };  
  
    var getData = function(elem, key){  
        var id = elem[expando];  //取得cache里跟dom节点关联的key  
        return cache[id] &amp;amp;&amp;amp; cache[id][key] || null;  //如果缓存里没有, 返回null  
    }  
  
    return {  
        setData: setData,  
        getData: getData      
    }  
}()  
  
&amp;lt;/script&amp;gt;  
  
var div = document.getElementById(&quot;ddd&quot;);  
Data.setData(div, &quot;name&quot;, &quot;zengtan&quot;);  
var value = Data.getData(div, &quot;name&quot;);  
alert (value)  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看看源码实现. &lt;/p&gt;

&lt;p&gt;首先声明一些特殊的节点, 在它们身上存属性的时候可能会抛出异常. &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;noData: {  
        &quot;embed&quot;: true,  
        // Ban all objects except for Flash (which handle expandos)  
        &quot;object&quot;: &quot;clsid:D27CDB6E-AE6D-11cf-96B8-444553540000&quot;,  
        &quot;applet&quot;: true  
    }  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个对象里的数据用在acceptData方法中, 跟1.42版本相比, 这里多了对什么flash的object的特殊处理. 
总之acceptData方法就是判断节点能否添加缓存. &lt;/p&gt;

&lt;p&gt;看具体的jQuery.data &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;data: function( elem, name, data ) {  
    if ( !jQuery.acceptData( elem ) ) {  
        return;  
    }  
    //noData类型  
    elem = elem == window ?  
        windowData :  
        elem;  
    //处理elem是window的情况, 如果不单独处理的话, 等于增加了一个全局变量, windowData也是一个{}  
    var isNode = elem.nodeType,  
    //判断是不是dom节点,由于非dom节点的缓存在继承和内存泄露上都会造成麻烦,1.43版本已经把dom节点和其他对象分开处理了.  
        id = isNode ? elem[ jQuery.expando ] : null,  
        cache = jQuery.cache, thisCache;  
    //因为存数据的时候, 会给elem[ jQuery.expando ]设置一个全局唯一标志量. 判断id是否为undefined, 就知道已经有没有往这个元素上缓存过数据.   
  
    if ( isNode &amp;amp;&amp;amp; !id &amp;amp;&amp;amp; typeof name === &quot;string&quot; &amp;amp;&amp;amp; data === undefined ) {  
    //如果是dom节点对象, 并且现在是get方式(typeof name === &quot;string&quot; &amp;amp;&amp;amp; data === undefined表示get方式), 又没有缓存(!id表示没有缓存).  
        return;  
    }  
  
    if ( !isNode ) {  
        cache = elem;  
    //如果是非dom节点对象, 取缓存里的属性就直接取元素本身属性.  
    } else if ( !id ) {  
        elem[ jQuery.expando ] = id = ++jQuery.uuid;  
    //第一次进行缓存, 分配一个全局唯一标志id.  
    }  
  
    if ( typeof name === &quot;object&quot; ) {  
    //如果key是对象类型  
        if ( isNode ) {  
            cache[ id ] = jQuery.extend(cache[ id ], name);  
    /* 
    把整个对象都复制到原来的缓存上, 比如 
         $(&#39;#ddd&#39;).data({ 
                &quot;v2&quot;: &quot;bbb&quot;, 
                &quot;v3&quot;: &quot;ccc&quot; 
            }); 
            相当于$(&#39;#ddd&#39;).data(&quot;v2&quot;, &quot;bbb&quot;).data(&quot;v3&quot;:&quot;ccc&quot;); 
            1.42版本用的cache[ id ] = jQuery.extend(true, {}, name). 这样会清空以前的缓存. 
        */  
        } else {  
            jQuery.extend( cache, name );  
        //如果不是dom节点. 把属性复制到元素本身.  
        }  
  
    } else if ( isNode &amp;amp;&amp;amp; !cache[ id ] ) {  
        //如果cache[ id ]中没有东西, 表示这个元素第一次进行缓存或者缓存已被清空, 设置cache[ id ]为一个新的map.  
        cache[ id ] = {};  
    }  
  
    thisCache = isNode ? cache[ id ] : cache;  
  
    if ( data !== undefined ) {  
        /* 
            set操作, 也可以防止一些意外的情况下缓存被清空. 比如data未定义的情况下, 缓存操作是无效的. 
            var a = {}; 
            var b; 
            $(a).data(&quot;c&quot;, 3); 
            $(a).data(&quot;c&quot;, b); b为undefined. 这句是无效的. 要移除缓存可以用removeData方法. 
        */  
        thisCache[ name ] = data;  
        //即cache[ id ][ name ] = data, 把data设置进cache缓存对象中, 前面分配的自增id当做key来关联  
    }  
  
    return typeof name === &quot;string&quot; ? thisCache[ name ] : thisCache;  
    //如果key是string类型, 返回key对应的缓存, 否则返回整个元素上的缓存  
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从新版本的源码里可以看到,  1.42版本中data方法的几个缺点已经被解决了. &lt;/p&gt;

&lt;p&gt;当然我们用jquery缓存系统的时候, 一般调用的是prototype方法, prototype方法除了调用上面的静态方法之外. 还加入了对节点上自定义事件的处理, 留在event部分再讲. &lt;/p&gt;

&lt;p&gt;当然, 我们还需要删除缓存的方法. 现在看看removeData的代码 &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Jquery.removeData  
  
    removeData: function( elem, name ) {  
        if ( !jQuery.acceptData( elem ) ) {  
            return;  
        }  
  
        elem = elem == window ?  
            windowData :  
            elem;  
  
        var isNode = elem.nodeType,  
            id = isNode ? elem[ jQuery.expando ] : elem,  
            //id是该元素在cache上面的key, 如果不是节点就返回元素本身.  
            cache = jQuery.cache,  
            thisCache = isNode ? cache[ id ] : id;  
  
        if ( name ) {  
            if ( thisCache ) {  
                delete thisCache[ name ];  
                //删除key对应的缓存数据  
                if ( isNode &amp;amp;&amp;amp; jQuery.isEmptyObject(thisCache) ){  
                    //如果元素是dom节点并且缓存为一个空对象.说明所有缓存的数据都已经被删掉了.  
                    //那么重新调用一次removeData方法, 删掉缓存系统里已经无用的东西, 防止内存泄露, 注意现在走的是下面else分支.   
                    jQuery.removeData( elem );   
                }  
            }  
        } else {  
            if ( isNode &amp;amp;&amp;amp; jQuery.support.deleteExpando ) {  
                //如果支持delete, 见特性检测部分.  
                delete elem[ jQuery.expando ];  
                //删掉元素的jQuery.expando属性  
  
            } else if ( elem.removeAttribute ) {  
                //如果支持removeAttribute  
                elem.removeAttribute( jQuery.expando );  
  
            } else if ( isNode ) {  
                delete cache[ id ];  
                //如果是dom节点, 全局缓存里删除以这个id为key的对象.  
            } else {  
                for ( var n in elem ) {  
                    //如果是其它对象, 删除对象的所有属性. 防止内存泄露.  
                    delete elem[ n ];  
                }  
            }  
        }  
    }  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-1&quot;&gt;队列控制&lt;/h3&gt;
&lt;p&gt;队列控制也是jquery中很有特点的一个功能. 可以用来管理动画或者事件等的执行顺序. queue和dequeue主要为动画服务. 
比如在jquery的动画里, 因为javascript的单线程异步机制, 如果要管理一批动画的执行顺序, 而不是让它们一起在屏幕上飞舞. 
一般我们是一个一个的把下个动画写在上个动画的回调函数中, 意味着如果要让十个动画按次序执行. 至少要写9个回调函数. 
好吧我承认我做过这样的事, 直接导致我的视力从5.2变为5.1. &lt;/p&gt;

&lt;p&gt;现在有了队列机制, 可以把动画都放到队列中依次执行.究竟怎样把动画填充进队列.用的是queue方法. 
不过queue非常先进的是.把动画push进队列之后,还会自动去执行队列里的第一个函数. 
队列机制里面的另外一个重要方法是dequeue, 意为取出队列的第一个函数并执行.此时队列里面的函数个数变为N-1. &lt;/p&gt;

&lt;p&gt;看个例子.比如我要让2个div以动画效果交替隐藏和显示.同时只能有一个div在进行动画. &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;style type=&quot;text/css&quot;&amp;gt;   
#div1 {background:#aaa;width:188px;height:188px;position:absolute;top:10px;left: 110px;}  
#div2 {background:#aaa;width:188px;height:188px;position:absolute;top:310px;left: 110px;}  
&amp;lt;/style&amp;gt;  
  
&amp;lt;body&amp;gt;   
&amp;lt;div id=&quot;div1&quot;&amp;gt;我是一个div&amp;lt;/div&amp;gt;  
&amp;lt;div id=&quot;div2&quot;&amp;gt;我是另一个div&amp;lt;/div&amp;gt;  
&amp;lt;/body&amp;gt;  
  
//用queue可以这样做.  
&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;  
$(document).queue([  
    function(fn){  
        $(&quot;#div1&quot;).hide(1000, fn);   
      //fn === $(document).dequeue;  
    },  
    function(fn){  
        $(&quot;#div2&quot;).hide(1000, fn);  
    },  
    function(fn){  
        $(&quot;#div1&quot;).show(1000, fn);  
    },  
    function(fn){  
        $(&quot;#div2&quot;).show(1000, fn);  
    }  
])  
&amp;lt;/script&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先我们需要一个载体, 来保存这个队列, 这里选择了document. 其实选什么节点都一样, 保存队列其实也是一个jQuery.data操作.
然后queue的参数是一个数组. 里面的函数就是队列依次执行的函数. 前面讲到, queue方法会自动把队列里的第一个函数取出来执行. 
意味着这些代码写完后, div1已经开始渐渐隐藏了. 隐藏完毕后, 如果要让后面的动画继续执行, 还要用$(document).dequeue()继续取出并执行现在队列里的第一个函数. 
当然这个操作是放在第一个动画的回调函数里, 以此类推, 第二个.dequeue()要放在第二个动画的回调函数里. 
我们看到这里没有用$(document).dequeue(). 因为这句代码太长. 注意队列函数里有一个参数fn, fn是dequeue方法内部传给此函数的, 就是$(document).dequeue(). &lt;/p&gt;

&lt;p&gt;在看源码之前, 先自己来想想这个功能应该怎么实现. 
首先我们需要一个数组, 里面存放那些动画. 然后需要2个方法, set和get.可以存取动画. 
可能我们还需要一个变量来模拟线程锁, 保证队列里的函数不会同时被执行. 
最后我们要把这个数组存入dom的缓存中, 方便随时存取和删除. &lt;/p&gt;

&lt;p&gt;看源码, 先是prototype方法. &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jQuery.prototype.queue = function( type, data ) {  
        if ( typeof type !== &quot;string&quot; ) {  
            data = type;  
            type = &quot;fx&quot;;    
//修正type, 默认为表示jquery动画的fx, 如果不为&quot;fx&quot;, 即为自己的自定义动画, 一般我们用&quot;fx&quot;就足够了.  
        }  
        if ( data === undefined ) {   
            return jQuery.queue( this[0], type );    
//get队列. 不论集合中是单个或者多个元素, 总是返回第一个元素的队列  
        }  
        return this.each(function( i, elem ) {    
//set队列, 遍历集合内所有元素  
            var queue = jQuery.queue( this, type, data );    
//set并返回队列  
            if ( type === &quot;fx&quot; &amp;amp;&amp;amp; queue[0] !== &quot;inprogress&quot; ) {  
         //防止在执行函数的时候, 这里又进行dequeue操作, 这样会同时执行2个函数, 队列就不受控制了.  
                jQuery.dequeue( this, type );      
//如果队列没有被锁住, 即此时没有在执行dequeue. 移出队列里第一个函数并执行它.  
//毕竟queue的主要任务是添加队列, 执行函数的操作上, 只能当二等公民.  
            }  
        });  
    }  
看看jQuery.queue这个静态方法.  
    jQuery.queue = function( elem, type, data ) {  
        if ( !elem ) {  
            return;  
        }  
        type = (type || &quot;fx&quot;) + &quot;queue&quot;;  
        var q = jQuery.data( elem, type );  
        //取得元素缓存上面的队列  
        if ( !data ) {    
        //如果当data为空, 只是查询queue. 那么返回队列或者[]  
return q || [];  
        }  
        if ( !q || jQuery.isArray(data) ) {  
            q = jQuery.data( elem, type, jQuery.makeArray(data) );   
        /*否则是set操作，注意!q || jQuery.isArray(data)这句代码的含义,   
		如果q为null, 说明缓存上没有队列. 此时哪怕队列里只有一个函数, 也把它转成数组, 保证队列是数组形式  
        如果q不为null, 说明缓存上已经存在队列, 但是如果现在被添加的函数是一个数组的话, 以现在的数组来代替原来的队列, 即把原来的队列清空了.  
        clearQueue函数就是用的这一句代码执行清空队列操作. 
        */    
} else {  
            q.push( data );  
        //缓存上有队列并且只添加一个函数  
        }  
        return q;  
    }  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再看dequeue, dequeue的原型方法什么也没做, 直接把参数交给jQuery.dequeue来处理.  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dequeue: function( elem, type ) {  
    type = type || &quot;fx&quot;;  
    var queue = jQuery.queue( elem, type ), fn = queue.shift();  
    //取得队列, 和队列里的第一个元素, 这里直接给shift掉了, 先斩后奏.  
    if ( fn === &quot;inprogress&quot; ) {  
        //如果fn===” inprogress”, 说明杀错了人, 我要找的是函数  
        fn = queue.shift();  
        //继续找下一个, 下一个肯定是函数了.  
        }  
        if ( fn ) {  
            if ( type === &quot;fx&quot; ) {  
                queue.unshift(&quot;inprogress&quot;);  
        //函数执行前, 在queue数组的最前面添加一个进程锁, 复活刚才杀错的人.   
		 	  }  
  
            fn.call(elem, function() {  
        //执行函数, 参数就是前面的fn  
                jQuery.dequeue(elem, type);  
            });  
        }  
	}  
})  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;“inprogress”进程锁是这样工作的： 
如果是dequeue操作, 去掉锁, 执行队列里的函数, 同时给队列加上锁. 如果是queue操作, 要看锁的状态, 如果被锁上了, 就只执行队列的添加操作. 不再调用dequeue. 
其实dequeue和queue都可以执行队列里的第一个函数.queue操作添加完队列之后, 会调用dequeue方法去执行函数. 
但是用dequeue执行函数的时候, 这时候如果又用queue触发dequeue的话, 很可能同时有2个函数在执行. 队列就失去一大半意义了(还是可以保证顺序, 但是2个动画会同时执行). 
不过这个锁只能保证在dequeue的时候, 不被queue操作意外的破坏队列. 
如果人为的同时用2个dequeue, 还是会破坏动画效果的. 所以要把fn写在回调函数里. &lt;/p&gt;

&lt;p&gt;清空队列 &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;clearQueue: function( type ) {  
    return this.queue( type || &quot;fx&quot;, [] );  
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;原理上面已经提到过了, 就是这一句 &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if ( !q || jQuery.isArray(data) ) {  
    q = jQuery.data( elem, type, jQuery.makeArray(data) );   
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用一个空数组代替了原来的队列. &lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;多库共存&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;jQuery.noConflict&lt;/code&gt;
将变量$的控制权让渡给上一个实现它的那个库. 
可能很多人都被多库共存时的$变量问题困扰过. 比如你先引入了prototype库,然后又引入了jquery.因为jquery的$会覆盖prototype的$. 
现在想调用prototype的$怎么办呢, noConflict方法就派上用场了. 
Jquery代码里最开始就有一句&lt;code&gt;_$ = window.$ &lt;/code&gt;, 在加载的时候就用&lt;code&gt;_$&lt;/code&gt;来引用原来的&lt;code&gt;$&lt;/code&gt; (比如现在就是prototype库里的$). &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jQuery.extend({     
    noConflict: function( deep ) {  
        window.$ = _$;     
//window.$归还给原来的库. 要回归jquery再用window.$ = jQuery就可以了.  
        if ( deep ) {      
            window.jQuery = _jQuery;     
//如果deep为true, jQuery这个变量也可以归还, 不过一般不需要也不推荐这么做.  
        }  
        return jQuery;  
    }  
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-3&quot;&gt;继承和拷贝&lt;/h4&gt;
&lt;p&gt;jQuery.prototype.extend和jQuery.extend 
扩展 jQuery 元素集来提供新的方法, 或者把一个对象的属性拷贝到另外一个对象上. 
通常javascript的继承实现有4种方式. 
1	构造继承 
2	prototype继承 
3	属性拷贝 
4	实例继承(这个有点特殊, 主要用于继承内置对象) &lt;/p&gt;

&lt;p&gt;这4种继承都有各自的优点和缺陷. 
构造继承查找属性快.但无法继承原型链上的方法,而且每次都要为属性复制一份新的副本进行储存 
原型继承在性能方面好一些,可以共享原型链.但查找属性慢,因为可能要遍历N条原型链才能找到某个属性.而且原型链太多,会使得结构越加混乱.并且会丢失对象的constructor属性 
(对象的constructor总是指向原型链最上层的构造器) 
属性拷贝非常灵活,但明显效率偏低. 而且仅仅只是模拟继承. 
实例继承主要用来继承Array, Date等内置对象, 用的较少. &lt;/p&gt;

&lt;p&gt;jquery里采用的是属性拷贝.其实用哪种继承是个见仁见智的问题. 也有其它一些库就是用的原型继承. &lt;/p&gt;

&lt;p&gt;前面也可以注意到, jquery只在构造方法或者原型链上定义了少量的核心方法. 其它功能块都是通过extend函数拷贝上去.按需定制. 
好比开发商交给我们房子的时候, 只安装了水电暖气等基本设施.电视机洗衣机显然是自己去买比较好. &lt;/p&gt;

&lt;p&gt;属性拷贝原理就是遍历第二个对象, 然后分别把键和值填入第一个对象中.类似于 &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for (var i in obj2){  
    Obj1[i] = obj2[i]  
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不幸的是jquery里面的做法复杂的多,不仅可以把多个参数的属性都复制到一个对象中,还能实现深度继承. 
深度继承是指如果被继承对象和继承对象都有同名属性a, 而且这个属性的值分别是一个对象b和c.会把b和c的属性都合并到一个新的对象里, 作为值返回给合并后的对象. 
说的有点复杂, 看个例子.   &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jQuery.extend( true,          
     { name: “John”, location: { city: “Boston” } },         
     { last: “Resig”, location: { state: “MA” } }         
 );          
  //结果为         
   {   
	  name: “John”, last: “Resig”,          
    location: { city: “Boston”, state: “MA” }   
   }  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;jQuery的做法主要是这样, 先修正参数,根据第一个参数是boolean还是object确定target是哪个对象. 
如果有且只有一个object类型的参数, 则把这个参数里的属性copy到jQuery或者jQuery.prototype上, 扩展jQuery对象.用这个办法可以很方便的编写插件. 
否则依次遍历第一个object参数之后的所有object类型对象的属性. 根据是否深度继承用不同的方式进行copy操作. 
extend会改变第一个参数的引用. 如果不想改变它,可以稍微变通一下,把所有的参数属性都拷贝到一个空对象上.如$.extend({}, obj1, obj2); &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jQuery.extend = jQuery.fn.extend = function() {  
    var target = arguments[0] || {}, i = 1, length = arguments.length, deep = false, options, name, src, copy, copyIsArray;  
    //target应该指向被拷贝的对象, deep表示深度拷贝或者浅度拷贝, 如果为true,即深度拷贝.反之为浅度拷贝.  
  
    if ( typeof target === &quot;boolean&quot; ) {  
    //如果显示声明了是深度拷贝还是浅度拷贝  
        deep = target;  
    //重新设置deep  
        target = arguments[1] || {};  
    //修正target, 让它指向第二个参数  
        i = 2;  
    //修正循环开始的位置, copy的时候跳过deep和target, 指向第一个copy对象.  
    }  
  
    if ( typeof target !== &quot;object&quot; &amp;amp;&amp;amp; !jQuery.isFunction(target) ) {  
        //修正target. 确保target是一个可以迭代属性的对象, 从这句代码看出target可以为函数对象  
        target = {};  
    }  
    if ( length === i ) {  
        target = this;  
        --i;  
        /* 
            当只有一个参数是对象的情况(可能前面还有一个true或false).  
            把属性赋值给jquery或者jquery.fn. 帮jquery实现继承. 
            并且重新修正循环起始位置. 
        */  
    }  
  
    for ( ; i &amp;lt; length; i++ ) {  
        if ( (options = arguments[ i ]) != null ) {  
            //只遍历不为null的参数  
            for ( name in options ) {  //遍历copy对象的属性  
                src = target[ name ];    //记录target的属性值  
                copy = options[ name ];  //记录将要被copy进去的值  
                if ( target === copy ) { //防止死循环???  
                    continue;  
                }  
  
                if ( deep &amp;amp;&amp;amp; copy &amp;amp;&amp;amp; ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {  
                    //如果是深度继承并且copy是对象字面量或者数组, 但必须保证至少为对象字面量和数组之一才会继续下面.  
                    //copyIsArray = jQuery.isArray(copy)返回的是boolean.  
                    //如果jQuery.isPlainObject(copy)和jQuery.isArray(copy)都是false,那整个if语句里的判断条件都返回false,  
                    //也就不会执行下面了的深度继承了.比起1.42版本, 很多地方功能没变, 代码还是明显清晰了很多.  
                    if ( copyIsArray ) {   //如果是数组  
                        copyIsArray = false; //重设copyIsArray  
                        clone = src &amp;amp;&amp;amp; jQuery.isArray(src) ? src : [];  
                    //防止深度copy的时候, target为undefined. 此时target应该为对象类型.   
                    //如果target本来为undefined, 要设一个不含属性的默认值, 且类型要跟copy对象保持一致.  
                    } else {  
                        clone = src &amp;amp;&amp;amp; jQuery.isPlainObject(src) ? src : {};  
                    //同上  
                    }  
                    target[ name ] = jQuery.extend( deep, clone, copy );  
                    //深度继承递归调用extend方法进行合并  
                } else if ( copy !== undefined ) {  
                    target[ name ] = copy;  
                    //浅度继承直接复制属性, 但是不要带入undefined值.  
                }  
            }  
        }  
    }  
  
    return target;  
    //返回合并后的对象. 第一个obj参数的引用已经被改变了.  
}  
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 
</feed>